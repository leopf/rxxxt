{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"rxxxt (R-3-X-T)","text":"<p>Server side rendered, reactive web applications in python.</p> <p>1 dependency (pydantic).</p> <p>Features: - stateless and stateful sessions - server to client updates - integrated state management - background workers - routing and navigation - partial page updates - more...</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>App</li> <li>Elements</li> <li>Component</li> <li>State</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install rxxxt\n</code></pre> <p>If you want to run the application, you will have to install an ASGI web server like uvicorn (with <code>[standard]</code> to allow for websockets) as well: <pre><code>pip install rxxxt uvicorn[standard]\n</code></pre></p>"},{"location":"#usage","title":"Usage","text":"<p><pre><code>import uvicorn\nfrom rxxxt import Component, event_handler, El, Element, App, local_state\n\nclass Counter(Component):\n  count = local_state(int)\n\n  @event_handler()\n  def on_click(self):\n    self.count += 1\n\n  def render(self) -&gt; Element:\n    return El.div(onclick=self.on_click, content=[f\"Count: {self.count}\"])\n\napp = App(Counter)\nuvicorn.run(app)\n</code></pre> result.webm</p>"},{"location":"#usage-with-fastapi","title":"Usage with FastAPI","text":"<pre><code>import uvicorn\nfrom fastapi import FastAPI, Response\nfrom rxxxt import local_state, Component, event_handler, El, Element, App, PageBuilder, VEl\n\nclass Counter(Component):\n  count = local_state(int)\n\n  @event_handler()\n  def on_click(self):\n    self.count += 1\n\n  def render(self) -&gt; Element:\n    return El.div(onclick=self.on_click, content=[f\"Count: {self.count}\"])\n\nserver = FastAPI()\n\n@server.get(\"/main.css\")\ndef get_css():\n  return Response(\"body { margin: 0; font-family: sans-serif; }\", media_type=\"text/css\")\n\npage_builder = PageBuilder()\npage_builder.add_header(VEl.link(rel=\"stylesheet\", href=\"/main.css\"))\n\napp = App(Counter, page_factory=page_builder)\nserver.mount(\"/\", app)\nuvicorn.run(server)\n</code></pre>"},{"location":"#notes","title":"Notes","text":"<ul> <li>after restarting python, your browser session will stop working (until you refresh), because your old state has been invalidated. Make sure to set <code>JWT_SECRET</code> to avoid this.</li> </ul>"},{"location":"api/","title":"API","text":""},{"location":"api/#rxxxt.app.App","title":"App","text":"<pre><code>App(content: ElementFactory, state_resolver: StateResolver | None = None, page_factory: PageFactory = default_page, config: AppConfig | None = None)\n</code></pre> <p>Methods:</p> Name Description <code>__call__</code> Source code in <code>rxxxt/app.py</code> <pre><code>def __init__(self, content: ElementFactory, state_resolver: StateResolver | None = None, page_factory: PageFactory = default_page, \\\n    config: AppConfig | None = None) -&gt; None:\n  self._content = content\n  self._page_factory: PageFactory = page_factory\n  self._state_resolver = state_resolver or default_state_resolver()\n  self._composer = Composer()\n  self._config = config or AppConfig()\n  _ = self._composer.add_handler(http_handler(routed_handler(\"/rxxxt-client.js\")(self._http_static_rxxxt_client_js)))\n  _ = self._composer.add_handler(http_handler(self._http_post_session))\n  _ = self._composer.add_handler(http_handler(self._http_get_session))\n  _ = self._composer.add_handler(websocket_handler(self._ws_session))\n  _ = self._composer.add_handler(http_not_found_handler)\n</code></pre>"},{"location":"api/#rxxxt.app.App.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(scope: ASGIScope, receive: ASGIFnReceive, send: ASGIFnSend) -&gt; Any\n</code></pre> Source code in <code>rxxxt/app.py</code> <pre><code>async def __call__(self, scope: ASGIScope, receive: ASGIFnReceive, send: ASGIFnSend) -&gt; Any:\n  return await self._composer(scope, receive, send)\n</code></pre>"},{"location":"api/#rxxxt.asgi.ASGIFnReceive","title":"ASGIFnReceive  <code>module-attribute</code>","text":"<pre><code>ASGIFnReceive = Callable[[], Awaitable[MutableMapping[str, Any]]]\n</code></pre>"},{"location":"api/#rxxxt.asgi.ASGIFnSend","title":"ASGIFnSend  <code>module-attribute</code>","text":"<pre><code>ASGIFnSend = Callable[[MutableMapping[str, Any]], Awaitable[Any]]\n</code></pre>"},{"location":"api/#rxxxt.asgi.ASGIHandler","title":"ASGIHandler  <code>module-attribute</code>","text":"<pre><code>ASGIHandler = Callable[[ASGIScope, ASGIFnReceive, ASGIFnSend], Awaitable[Any]]\n</code></pre>"},{"location":"api/#rxxxt.asgi.ASGINextException","title":"ASGINextException","text":"<p>               Bases: <code>Exception</code></p>"},{"location":"api/#rxxxt.asgi.ASGIScope","title":"ASGIScope  <code>module-attribute</code>","text":"<pre><code>ASGIScope = MutableMapping[str, Any]\n</code></pre>"},{"location":"api/#rxxxt.asgi.Composer","title":"Composer","text":"<pre><code>Composer()\n</code></pre> <p>Methods:</p> Name Description <code>__call__</code> <code>add_handler</code> Source code in <code>rxxxt/asgi.py</code> <pre><code>def __init__(self) -&gt; None:\n  self._handlers: list[ASGIHandler] = []\n</code></pre>"},{"location":"api/#rxxxt.asgi.Composer.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(scope: ASGIScope, receive: ASGIFnReceive, send: ASGIFnSend) -&gt; Any\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def __call__(self, scope: ASGIScope, receive: ASGIFnReceive, send: ASGIFnSend) -&gt; Any:\n  try:\n    for handler in self._handlers:\n      try: return await handler(scope, receive, send)\n      except ASGINextException: pass\n  except asyncio.CancelledError: raise\n  except BaseException as e:\n    logging.debug(\"asgi error\", exc_info=True, stack_info=True)\n    if scope[\"type\"] == \"websocket\":\n      return await self._ws_error_handler(WebsocketContext(scope, receive, send), e)\n    if scope[\"type\"] == \"http\":\n      return await self._http_error_handler(HTTPContext(scope, receive, send), e)\n</code></pre>"},{"location":"api/#rxxxt.asgi.Composer.add_handler","title":"add_handler","text":"<pre><code>add_handler(handler: ASGIHandler)\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>def add_handler(self, handler: ASGIHandler):\n  self._handlers.append(handler)\n  return handler\n</code></pre>"},{"location":"api/#rxxxt.asgi.http_handler","title":"http_handler","text":"<pre><code>http_handler(fn: Callable[[HTTPContext], Awaitable[Any]])\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>def http_handler(fn: Callable[[HTTPContext], Awaitable[Any]]):\n  async def _inner(scope: ASGIScope, receive: ASGIFnReceive, send: ASGIFnSend) -&gt; Any:\n    if scope[\"type\"] != \"http\": raise ASGINextException()\n    return await fn(HTTPContext(scope, receive, send))\n  return _inner\n</code></pre>"},{"location":"api/#rxxxt.asgi.http_not_found_handler","title":"http_not_found_handler  <code>async</code>","text":"<pre><code>http_not_found_handler(context: HTTPContext)\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>@http_handler\nasync def http_not_found_handler(context: HTTPContext):\n  await context.respond_text(\"not found\", 404)\n</code></pre>"},{"location":"api/#rxxxt.asgi.HTTPContext","title":"HTTPContext","text":"<pre><code>HTTPContext(scope: ASGIScope, receive: ASGIFnReceive, send: ASGIFnSend)\n</code></pre> <p>               Bases: <code>TransportContext</code></p> <p>Methods:</p> Name Description <code>add_response_headers</code> <code>receive_bytes</code> <code>receive_iter</code> <code>receive_json</code> <code>receive_json_raw</code> <code>receive_text</code> <code>respond_file</code> <code>respond_text</code> <code>response_body</code> <code>response_start</code> <p>Attributes:</p> Name Type Description <code>method</code> Source code in <code>rxxxt/asgi.py</code> <pre><code>def __init__(self, scope: ASGIScope, receive: ASGIFnReceive, send: ASGIFnSend) -&gt; None:\n  super().__init__(scope, receive, send)\n  self._response_headers: list[tuple[BytesLike, BytesLike]] = []\n</code></pre>"},{"location":"api/#rxxxt.asgi.HTTPContext.method","title":"method  <code>property</code>","text":"<pre><code>method\n</code></pre>"},{"location":"api/#rxxxt.asgi.HTTPContext.add_response_headers","title":"add_response_headers","text":"<pre><code>add_response_headers(headers: ASGIHeaders)\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>def add_response_headers(self, headers: ASGIHeaders): self._response_headers.extend(headers)\n</code></pre>"},{"location":"api/#rxxxt.asgi.HTTPContext.receive_bytes","title":"receive_bytes  <code>async</code>","text":"<pre><code>receive_bytes() -&gt; bytes\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def receive_bytes(self) -&gt; bytes:\n  stream = io.BytesIO()\n  async for chunk in self.receive_iter():\n    _ = stream.write(chunk)\n  return stream.getvalue()\n</code></pre>"},{"location":"api/#rxxxt.asgi.HTTPContext.receive_iter","title":"receive_iter  <code>async</code>","text":"<pre><code>receive_iter() -&gt; AsyncGenerator[bytes, Any]\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def receive_iter(self) -&gt; AsyncGenerator[bytes, Any]:\n  while True:\n    event = await self.receive()\n    event_type = event.get(\"type\")\n    if event_type == \"http.request\":\n      yield event.get(\"body\", b\"\")\n      if not event.get(\"more_body\", False): return\n    elif event_type == \"http.disconnect\": return\n</code></pre>"},{"location":"api/#rxxxt.asgi.HTTPContext.receive_json","title":"receive_json  <code>async</code>","text":"<pre><code>receive_json()\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def receive_json(self): return json.loads(await self.receive_json_raw())\n</code></pre>"},{"location":"api/#rxxxt.asgi.HTTPContext.receive_json_raw","title":"receive_json_raw  <code>async</code>","text":"<pre><code>receive_json_raw()\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def receive_json_raw(self): return await self.receive_text({ \"application/json\" })\n</code></pre>"},{"location":"api/#rxxxt.asgi.HTTPContext.receive_text","title":"receive_text  <code>async</code>","text":"<pre><code>receive_text(allowed_mime_types: Iterable[str])\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def receive_text(self, allowed_mime_types: Iterable[str]):\n  allowed_mime_types = allowed_mime_types if isinstance(allowed_mime_types, set) else set(allowed_mime_types)\n  mime_type, ct_params = self.content_type\n  if mime_type not in allowed_mime_types: raise ValueError(f\"Mime type '{mime_type}' is not in allowed types!\")\n  charset = ct_params.get(\"charset\", \"utf-8\")\n  try: decoder = codecs.getdecoder(charset)\n  except LookupError: raise ValueError(\"Invalid content-type encoding!\")\n  data = await self.receive_bytes()\n  return decoder(data, \"ignore\")[0]\n</code></pre>"},{"location":"api/#rxxxt.asgi.HTTPContext.respond_file","title":"respond_file  <code>async</code>","text":"<pre><code>respond_file(path: str | Path, mime_type: str | None = None, handle_404: bool = False, use_last_modified: bool = False)\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def respond_file(self, path: str | pathlib.Path, mime_type: str | None = None, handle_404: bool = False, use_last_modified: bool = False):\n  mime_type = mime_type or mimetypes.guess_type(path)[0]\n  if mime_type is None: raise ValueError(\"Unknown mime type!\")\n  ppath = pathlib.Path(path)\n  if handle_404 and not ppath.exists():\n    return await self.respond_text(\"not found\", 404)\n\n  with open(ppath, \"rb\") as fd:\n    fd_stat = os.stat(fd.fileno())\n\n    if use_last_modified:\n      last_modified = formatdate(fd_stat.st_mtime, usegmt=True).encode()\n      self.add_response_headers([ (b\"Last-Modified\", last_modified) ])\n      if (last_modified,) == self.headers.get(\"If-Modified-Since\", None):\n        await self.response_start(304)\n        await self.response_body(b\"\", False)\n        return\n\n    self.add_response_headers(content_headers(fd_stat.st_size, mime_type))\n    await self.response_start(200)\n    while len(data := fd.read(1_000_000)) != 0:\n      await self.response_body(data, fd.tell() != fd_stat.st_size)\n</code></pre>"},{"location":"api/#rxxxt.asgi.HTTPContext.respond_text","title":"respond_text  <code>async</code>","text":"<pre><code>respond_text(text: str, status: int = 200, mime_type: str = 'text/plain')\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def respond_text(self, text: str, status: int = 200, mime_type: str = \"text/plain\"):\n  data = text.encode(\"utf-8\")\n  self.add_response_headers(content_headers(len(data), mime_type + \"; charset=utf-8\"))\n  await self.response_start(status)\n  await self.response_body(data, False)\n</code></pre>"},{"location":"api/#rxxxt.asgi.HTTPContext.response_body","title":"response_body  <code>async</code>","text":"<pre><code>response_body(data: BytesLike, more_body: bool)\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def response_body(self, data: BytesLike, more_body: bool):\n  await self.send({\n    \"type\": \"http.response.body\",\n    \"body\": data,\n    \"more_body\": more_body\n  })\n</code></pre>"},{"location":"api/#rxxxt.asgi.HTTPContext.response_start","title":"response_start  <code>async</code>","text":"<pre><code>response_start(status: int, trailers: bool = False)\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def response_start(self, status: int, trailers: bool = False):\n  await self.send({\n    \"type\": \"http.response.start\",\n    \"status\": status,\n    \"headers\": self._response_headers,\n    \"trailers\": trailers\n  })\n</code></pre>"},{"location":"api/#rxxxt.asgi.routed_handler","title":"routed_handler","text":"<pre><code>routed_handler(pattern: str)\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>def routed_handler(pattern: str):\n  def _inner(fn: Callable[[CTXT, dict[str, str]], Awaitable[Any]]) -&gt; Callable[[CTXT], Awaitable[Any]]:\n    async def _inner_inner(context: CTXT) -&gt; Any:\n      if (match:=match_path(pattern, context.path)) is None: context.next()\n      return await fn(context, match)\n    return _inner_inner\n  return _inner\n</code></pre>"},{"location":"api/#rxxxt.asgi.TransportContext","title":"TransportContext","text":"<pre><code>TransportContext(scope: ASGIScope, receive: ASGIFnReceive, send: ASGIFnSend)\n</code></pre> <p>Methods:</p> Name Description <code>next</code> <p>Attributes:</p> Name Type Description <code>content_type</code> <code>fullpath</code> <code>headers</code> <code>location</code> <code>path</code> <code>query_string</code> <code>str | None</code> <code>receive</code> <code>scope</code> <code>send</code> Source code in <code>rxxxt/asgi.py</code> <pre><code>def __init__(self, scope: ASGIScope, receive: ASGIFnReceive, send: ASGIFnSend) -&gt; None:\n  self.scope = scope\n  self.receive = receive\n  self.send = send\n</code></pre>"},{"location":"api/#rxxxt.asgi.TransportContext.content_type","title":"content_type  <code>cached</code> <code>property</code>","text":"<pre><code>content_type\n</code></pre>"},{"location":"api/#rxxxt.asgi.TransportContext.fullpath","title":"fullpath  <code>property</code>","text":"<pre><code>fullpath\n</code></pre>"},{"location":"api/#rxxxt.asgi.TransportContext.headers","title":"headers  <code>cached</code> <code>property</code>","text":"<pre><code>headers\n</code></pre>"},{"location":"api/#rxxxt.asgi.TransportContext.location","title":"location  <code>property</code>","text":"<pre><code>location\n</code></pre>"},{"location":"api/#rxxxt.asgi.TransportContext.path","title":"path  <code>property</code>","text":"<pre><code>path\n</code></pre>"},{"location":"api/#rxxxt.asgi.TransportContext.query_string","title":"query_string  <code>property</code>","text":"<pre><code>query_string: str | None\n</code></pre>"},{"location":"api/#rxxxt.asgi.TransportContext.receive","title":"receive  <code>instance-attribute</code>","text":"<pre><code>receive = receive\n</code></pre>"},{"location":"api/#rxxxt.asgi.TransportContext.scope","title":"scope  <code>instance-attribute</code>","text":"<pre><code>scope = scope\n</code></pre>"},{"location":"api/#rxxxt.asgi.TransportContext.send","title":"send  <code>instance-attribute</code>","text":"<pre><code>send = send\n</code></pre>"},{"location":"api/#rxxxt.asgi.TransportContext.next","title":"next","text":"<pre><code>next()\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>def next(self): raise ASGINextException()\n</code></pre>"},{"location":"api/#rxxxt.asgi.websocket_handler","title":"websocket_handler","text":"<pre><code>websocket_handler(fn: Callable[[WebsocketContext], Awaitable[Any]])\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>def websocket_handler(fn: Callable[[WebsocketContext], Awaitable[Any]]):\n  async def _inner(scope: ASGIScope, receive: ASGIFnReceive, send: ASGIFnSend) -&gt; Any:\n    if scope[\"type\"] != \"websocket\": raise ASGINextException()\n    return await fn(WebsocketContext(scope, receive, send))\n  return _inner\n</code></pre>"},{"location":"api/#rxxxt.asgi.WebsocketContext","title":"WebsocketContext","text":"<pre><code>WebsocketContext(scope: ASGIScope, receive: ASGIFnReceive, send: ASGIFnSend)\n</code></pre> <p>               Bases: <code>TransportContext</code></p> <p>Methods:</p> Name Description <code>close</code> <code>receive_message</code> <code>send_message</code> <code>setup</code> <p>Attributes:</p> Name Type Description <code>connected</code> Source code in <code>rxxxt/asgi.py</code> <pre><code>def __init__(self, scope: ASGIScope, receive: ASGIFnReceive, send: ASGIFnSend) -&gt; None:\n  super().__init__(scope, receive, send)\n  self._connected = True\n</code></pre>"},{"location":"api/#rxxxt.asgi.WebsocketContext.connected","title":"connected  <code>property</code>","text":"<pre><code>connected\n</code></pre>"},{"location":"api/#rxxxt.asgi.WebsocketContext.close","title":"close  <code>async</code>","text":"<pre><code>close(code: int = 1000, reason: str = 'Normal Closure')\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def close(self, code: int = 1000, reason: str = \"Normal Closure\"):\n  await self.send({ \"type\": \"websocket.close\", \"code\": code, \"reason\": reason })\n  self._connected = False\n</code></pre>"},{"location":"api/#rxxxt.asgi.WebsocketContext.receive_message","title":"receive_message  <code>async</code>","text":"<pre><code>receive_message() -&gt; BytesLike | str\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def receive_message(self) -&gt; BytesLike | str:\n  while self._connected:\n    event = await self.receive()\n    if event[\"type\"] == \"websocket.disconnect\":\n      self._connected = False\n      raise ConnectionError(\"Connection closed!\")\n    elif event[\"type\"] == \"websocket.receive\":\n      return event.get(\"bytes\", event.get(\"text\"))\n  raise ConnectionError(\"Connection closed!\")\n</code></pre>"},{"location":"api/#rxxxt.asgi.WebsocketContext.send_message","title":"send_message  <code>async</code>","text":"<pre><code>send_message(data: str | BytesLike)\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def send_message(self, data: str | BytesLike):\n  if not self._connected: raise ConnectionError(\"Not connected!\")\n  event: dict[str, Any] = { \"type\": \"websocket.send\", \"bytes\": None, \"text\": None }\n  if isinstance(data, str): event[\"text\"] = data\n  else: event[\"bytes\"] = data\n  await self.send(event)\n</code></pre>"},{"location":"api/#rxxxt.asgi.WebsocketContext.setup","title":"setup  <code>async</code>","text":"<pre><code>setup(headers: ASGIHeaders = (), subprotocol: str | None = None)\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def setup(self, headers: ASGIHeaders = (), subprotocol: str | None = None):\n  event = await self.receive()\n  if event[\"type\"] != \"websocket.connect\": raise ConnectionError(\"Did not receive connect event!\")\n  await self.send({ \"type\": \"websocket.accept\", \"subprotocol\": subprotocol, \"headers\": [ (name.lower(), value) for name, value in headers ] })\n</code></pre>"},{"location":"api/#rxxxt.component.Component","title":"Component","text":"<pre><code>Component()\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Methods:</p> Name Description <code>add_job</code> <p>Runs a background job until completion. Only runs when the session is persistent.</p> <code>add_worker</code> <p>Runs a background worker, which may be cancelled at any time. Only runs when the session is persistent.</p> <code>lc_destroy</code> <code>lc_handle_event</code> <code>lc_init</code> <code>lc_render</code> <code>on_after_destroy</code> <code>on_after_update</code> <code>on_before_destroy</code> <code>on_before_update</code> <code>on_init</code> <code>render</code> <code>tonode</code> <p>Attributes:</p> Name Type Description <code>context</code> <code>Context</code> Source code in <code>rxxxt/component.py</code> <pre><code>def __init__(self) -&gt; None:\n  super().__init__()\n  self.context: Context\n  self._worker_tasks: list[asyncio.Task[Any]] = []\n  self._job_tasks: list[asyncio.Task[Any]] = []\n</code></pre>"},{"location":"api/#rxxxt.component.Component.context","title":"context  <code>instance-attribute</code>","text":"<pre><code>context: Context\n</code></pre>"},{"location":"api/#rxxxt.component.Component.add_job","title":"add_job","text":"<pre><code>add_job(a: Coroutine[Any, Any, Any])\n</code></pre> <p>Runs a background job until completion. Only runs when the session is persistent. args:   a: Coroutine - the coroutine that should be run</p> Source code in <code>rxxxt/component.py</code> <pre><code>def add_job(self, a: Coroutine[Any, Any, Any]):\n  \"\"\"\n  Runs a background job until completion. Only runs when the session is persistent.\n  args:\n    a: Coroutine - the coroutine that should be run\n  \"\"\"\n  if self.context.config.persistent:\n    self._worker_tasks.append(asyncio.create_task(a))\n  else: a.close()\n</code></pre>"},{"location":"api/#rxxxt.component.Component.add_worker","title":"add_worker","text":"<pre><code>add_worker(a: Coroutine[Any, Any, Any])\n</code></pre> <p>Runs a background worker, which may be cancelled at any time. Only runs when the session is persistent. args:   a: Coroutine - the coroutine that should be run</p> Source code in <code>rxxxt/component.py</code> <pre><code>def add_worker(self, a: Coroutine[Any, Any, Any]):\n  \"\"\"\n  Runs a background worker, which may be cancelled at any time. Only runs when the session is persistent.\n  args:\n    a: Coroutine - the coroutine that should be run\n  \"\"\"\n  if self.context.config.persistent:\n    self._worker_tasks.append(asyncio.create_task(a))\n  else: a.close()\n</code></pre>"},{"location":"api/#rxxxt.component.Component.lc_destroy","title":"lc_destroy  <code>async</code>","text":"<pre><code>lc_destroy() -&gt; None\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>async def lc_destroy(self) -&gt; None:\n  await self.on_before_destroy()\n  if len(self._job_tasks) &gt; 0:\n    try: _ = await asyncio.wait(self._job_tasks)\n    except asyncio.CancelledError: pass\n    self._job_tasks.clear()\n  if len(self._worker_tasks) &gt; 0:\n    for t in self._worker_tasks: _ = t.cancel()\n    try: _ = await asyncio.wait(self._worker_tasks)\n    except asyncio.CancelledError: pass\n    self._worker_tasks.clear()\n  await self.on_after_destroy()\n</code></pre>"},{"location":"api/#rxxxt.component.Component.lc_handle_event","title":"lc_handle_event  <code>async</code>","text":"<pre><code>lc_handle_event(event: dict[str, int | float | str | bool | None])\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>async def lc_handle_event(self, event: dict[str, int | float | str | bool | None]):\n  handler_name = event.pop(\"$handler_name\", None)\n  if isinstance(handler_name, str):\n    fn = getattr(self, handler_name, None) # NOTE: this is risky!!\n    if isinstance(fn, EventHandler):\n      await to_awaitable(cast(EventHandler[..., Any], fn), **event)\n</code></pre>"},{"location":"api/#rxxxt.component.Component.lc_init","title":"lc_init  <code>async</code>","text":"<pre><code>lc_init(context: Context) -&gt; None\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>async def lc_init(self, context: Context) -&gt; None:\n  self.context = context\n  await self.on_init()\n</code></pre>"},{"location":"api/#rxxxt.component.Component.lc_render","title":"lc_render  <code>async</code>","text":"<pre><code>lc_render() -&gt; Element\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>async def lc_render(self) -&gt; Element:\n  await self.on_before_update()\n  el = await to_awaitable(self.render)\n  try: self.context.execution.pending_updates.remove(self.context.id) # NOTE: remove any update that was requested during render\n  except KeyError: pass\n  await self.on_after_update()\n  return el\n</code></pre>"},{"location":"api/#rxxxt.component.Component.on_after_destroy","title":"on_after_destroy  <code>async</code>","text":"<pre><code>on_after_destroy() -&gt; None\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>async def on_after_destroy(self) -&gt; None: ...\n</code></pre>"},{"location":"api/#rxxxt.component.Component.on_after_update","title":"on_after_update  <code>async</code>","text":"<pre><code>on_after_update() -&gt; None\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>async def on_after_update(self) -&gt; None: ...\n</code></pre>"},{"location":"api/#rxxxt.component.Component.on_before_destroy","title":"on_before_destroy  <code>async</code>","text":"<pre><code>on_before_destroy() -&gt; None\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>async def on_before_destroy(self) -&gt; None: ...\n</code></pre>"},{"location":"api/#rxxxt.component.Component.on_before_update","title":"on_before_update  <code>async</code>","text":"<pre><code>on_before_update() -&gt; None\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>async def on_before_update(self) -&gt; None: ...\n</code></pre>"},{"location":"api/#rxxxt.component.Component.on_init","title":"on_init  <code>async</code>","text":"<pre><code>on_init() -&gt; None\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>async def on_init(self) -&gt; None: ...\n</code></pre>"},{"location":"api/#rxxxt.component.Component.render","title":"render  <code>abstractmethod</code>","text":"<pre><code>render() -&gt; Element | Awaitable[Element]\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>@abstractmethod\ndef render(self) -&gt; Element | Awaitable[Element]: ...\n</code></pre>"},{"location":"api/#rxxxt.component.Component.tonode","title":"tonode","text":"<pre><code>tonode(context: Context) -&gt; Node\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def tonode(self, context: Context) -&gt; 'Node': return ComponentNode(context, self)\n</code></pre>"},{"location":"api/#rxxxt.component.context_state","title":"context_state","text":"<pre><code>context_state(default_factory: Callable[[], T], name: str | None = None)\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def context_state(default_factory: Callable[[], T], name: str | None = None):\n  return StateDescriptor(get_context_state_key, default_factory, state_name=name)\n</code></pre>"},{"location":"api/#rxxxt.component.context_state_box","title":"context_state_box","text":"<pre><code>context_state_box(default_factory: Callable[[], T], name: str | None = None)\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def context_state_box(default_factory: Callable[[], T], name: str | None = None):\n  return StateBoxDescriptor(get_context_state_key, default_factory, state_name=name)\n</code></pre>"},{"location":"api/#rxxxt.component.event_handler","title":"event_handler","text":"<pre><code>event_handler(**kwargs: Any)\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def event_handler(**kwargs: Any):\n  options = InputEventDescriptorOptions.model_validate(kwargs)\n  def _inner(fn: Callable[Concatenate[Any, FNP], FNR]) -&gt; ClassEventHandler[FNP, FNR]: return ClassEventHandler(fn, options)\n  return _inner\n</code></pre>"},{"location":"api/#rxxxt.component.EventHandler","title":"EventHandler","text":"<pre><code>EventHandler(fn: Callable[Concatenate[Any, FNP], FNR], options: InputEventDescriptorOptions, instance: Any)\n</code></pre> <p>               Bases: <code>ClassEventHandler[FNP, FNR]</code>, <code>Generic[FNP, FNR]</code>, <code>CustomAttribute</code>, <code>InputEventDescriptorGenerator</code></p> <p>Methods:</p> Name Description <code>__call__</code> <code>bind</code> <code>get_key_values</code> <p>Attributes:</p> Name Type Description <code>descriptor</code> Source code in <code>rxxxt/component.py</code> <pre><code>def __init__(self, fn: Callable[Concatenate[Any, FNP], FNR], options: InputEventDescriptorOptions, instance: Any) -&gt; None:\n  super().__init__(validate_call(fn), options)\n  if not isinstance(instance, Component): raise ValueError(\"The provided instance must be a component!\")\n  self._instance: 'Component' = instance\n</code></pre>"},{"location":"api/#rxxxt.component.EventHandler.descriptor","title":"descriptor  <code>property</code>","text":"<pre><code>descriptor\n</code></pre>"},{"location":"api/#rxxxt.component.EventHandler.__call__","title":"__call__","text":"<pre><code>__call__(*args: args, **kwargs: kwargs) -&gt; FNR\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def __call__(self, *args: FNP.args, **kwargs: FNP.kwargs) -&gt; FNR: return self._fn(self._instance, *args, **kwargs)\n</code></pre>"},{"location":"api/#rxxxt.component.EventHandler.bind","title":"bind","text":"<pre><code>bind(**kwargs: int | float | str | bool | None)\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def bind(self, **kwargs: int | float | str | bool | None):\n  if len(kwargs) == 0: return\n  new_options = InputEventDescriptorOptions.model_validate({\n    **self._options.model_dump(),\n    \"default_params\": (self._options.default_params or {}) | kwargs\n  })\n  return EventHandler(self._fn, new_options, self._instance)\n</code></pre>"},{"location":"api/#rxxxt.component.EventHandler.get_key_values","title":"get_key_values","text":"<pre><code>get_key_values(original_key: str)\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def get_key_values(self, original_key: str):\n  if not original_key.startswith(\"on\"): raise ValueError(\"Event handler must be applied to an attribute starting with 'on'.\")\n  v = base64.b64encode(self.descriptor.model_dump_json(exclude_defaults=True).encode(\"utf-8\")).decode(\"utf-8\")\n  return ((f\"rxxxt-on-{original_key[2:]}\", v),)\n</code></pre>"},{"location":"api/#rxxxt.component.global_state","title":"global_state","text":"<pre><code>global_state(default_factory: Callable[[], T], name: str | None = None)\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def global_state(default_factory: Callable[[], T], name: str | None = None):\n  return StateDescriptor(get_global_state_key, default_factory, state_name=name)\n</code></pre>"},{"location":"api/#rxxxt.component.global_state_box","title":"global_state_box","text":"<pre><code>global_state_box(default_factory: Callable[[], T], name: str | None = None)\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def global_state_box(default_factory: Callable[[], T], name: str | None = None):\n  return StateBoxDescriptor(get_global_state_key, default_factory, state_name=name)\n</code></pre>"},{"location":"api/#rxxxt.component.HandleNavigate","title":"HandleNavigate","text":"<pre><code>HandleNavigate(location: str)\n</code></pre> <p>               Bases: <code>CustomAttribute</code></p> <p>Methods:</p> Name Description <code>get_key_values</code> <p>Attributes:</p> Name Type Description <code>location</code> Source code in <code>rxxxt/component.py</code> <pre><code>def __init__(self, location: str) -&gt; None:\n  super().__init__()\n  self.location = location\n</code></pre>"},{"location":"api/#rxxxt.component.HandleNavigate.location","title":"location  <code>instance-attribute</code>","text":"<pre><code>location = location\n</code></pre>"},{"location":"api/#rxxxt.component.HandleNavigate.get_key_values","title":"get_key_values","text":"<pre><code>get_key_values(original_key: str) -&gt; tuple[tuple[str, str], ...]\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def get_key_values(self, original_key: str) -&gt; tuple[tuple[str, str],...]:\n  return ((original_key, f\"window.rxxxt.navigate('{self.location}');\"),)\n</code></pre>"},{"location":"api/#rxxxt.component.local_state","title":"local_state","text":"<pre><code>local_state(default_factory: Callable[[], T], name: str | None = None)\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def local_state(default_factory: Callable[[], T], name: str | None = None):\n  return StateDescriptor(get_local_state_key, default_factory, state_name=name)\n</code></pre>"},{"location":"api/#rxxxt.component.local_state_box","title":"local_state_box","text":"<pre><code>local_state_box(default_factory: Callable[[], T], name: str | None = None)\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def local_state_box(default_factory: Callable[[], T], name: str | None = None):\n  return StateBoxDescriptor(get_local_state_key, default_factory, state_name=name)\n</code></pre>"},{"location":"api/#rxxxt.component.StateBox","title":"StateBox","text":"<pre><code>StateBox(key: str, state: State, default_factory: Callable[[], T], adapter: TypeAdapter[T])\n</code></pre> <p>               Bases: <code>Generic[T]</code>, <code>StateCell</code></p> <p>Methods:</p> Name Description <code>__enter__</code> <code>__exit__</code> <code>consume</code> <code>detach</code> <code>produce</code> <code>update</code> <p>Attributes:</p> Name Type Description <code>key</code> <code>value</code> Source code in <code>rxxxt/component.py</code> <pre><code>def __init__(self, key: str, state: State, default_factory: Callable[[], T], adapter: TypeAdapter[T]) -&gt; None:\n  super().__init__()\n  self._key = key\n  self._state = state\n  self._adapter = adapter\n  self._value: T\n\n  key_state = state.get(key)\n  key_state.add_consumer(self)\n  try: self._value = adapter.validate_json(key_state.get())\n  except ValueError:\n    self._value = default_factory()\n    key_state.set(self)\n</code></pre>"},{"location":"api/#rxxxt.component.StateBox.key","title":"key  <code>property</code>","text":"<pre><code>key\n</code></pre>"},{"location":"api/#rxxxt.component.StateBox.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value\n</code></pre>"},{"location":"api/#rxxxt.component.StateBox.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def __enter__(self): return self.value\n</code></pre>"},{"location":"api/#rxxxt.component.StateBox.__exit__","title":"__exit__","text":"<pre><code>__exit__(*_)\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def __exit__(self, *_): self.update()\n</code></pre>"},{"location":"api/#rxxxt.component.StateBox.consume","title":"consume","text":"<pre><code>consume(key: str, producer: Callable[[], str]) -&gt; Any\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def consume(self, key: str, producer: Callable[[], str]) -&gt; Any:\n  self._value = self._adapter.validate_json(producer())\n</code></pre>"},{"location":"api/#rxxxt.component.StateBox.detach","title":"detach","text":"<pre><code>detach(key: str) -&gt; Any\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def detach(self, key: str) -&gt; Any:\n  del self._value\n</code></pre>"},{"location":"api/#rxxxt.component.StateBox.produce","title":"produce","text":"<pre><code>produce(key: str) -&gt; str\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def produce(self, key: str) -&gt; str:\n  return self._adapter.dump_json(self._value).decode()\n</code></pre>"},{"location":"api/#rxxxt.component.StateBox.update","title":"update","text":"<pre><code>update()\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def update(self):\n  self._state.get(self._key).set(self)\n</code></pre>"},{"location":"api/#rxxxt.elements.add_attributes","title":"add_attributes","text":"<pre><code>add_attributes(base: HTMLAttributes, **kwargs: HTMLAttributeValue)\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>def add_attributes(base: HTMLAttributes, **kwargs: HTMLAttributeValue):\n  return merge_attributes(kwargs, base)\n</code></pre>"},{"location":"api/#rxxxt.elements.class_map","title":"class_map","text":"<pre><code>class_map(map: dict[str, bool])\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>def class_map(map: dict[str, bool]):\n  return \" \".join([ k for k, v in map.items() if v ])\n</code></pre>"},{"location":"api/#rxxxt.elements.CustomAttribute","title":"CustomAttribute","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> Name Description <code>get_key_values</code>"},{"location":"api/#rxxxt.elements.CustomAttribute.get_key_values","title":"get_key_values  <code>abstractmethod</code>","text":"<pre><code>get_key_values(original_key: str) -&gt; tuple[tuple[str, str | None], ...]\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>@abstractmethod\ndef get_key_values(self, original_key: str) -&gt; tuple[tuple[str, str | None],...]: ...\n</code></pre>"},{"location":"api/#rxxxt.elements.El","title":"El","text":""},{"location":"api/#rxxxt.elements.Element","title":"Element","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> Name Description <code>tonode</code>"},{"location":"api/#rxxxt.elements.Element.tonode","title":"tonode  <code>abstractmethod</code>","text":"<pre><code>tonode(context: Context) -&gt; Node\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>@abstractmethod\ndef tonode(self, context: Context) -&gt; Node: ...\n</code></pre>"},{"location":"api/#rxxxt.elements.ElementContent","title":"ElementContent  <code>module-attribute</code>","text":"<pre><code>ElementContent = Iterable[Element | str]\n</code></pre>"},{"location":"api/#rxxxt.elements.ElementFactory","title":"ElementFactory","text":"<p>               Bases: <code>Protocol</code></p> <p>Methods:</p> Name Description <code>__call__</code>"},{"location":"api/#rxxxt.elements.ElementFactory.__call__","title":"__call__","text":"<pre><code>__call__() -&gt; Element\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>def __call__(self) -&gt; Element: ...\n</code></pre>"},{"location":"api/#rxxxt.elements.HTMLAttributes","title":"HTMLAttributes  <code>module-attribute</code>","text":"<pre><code>HTMLAttributes = dict[str, str | bool | int | float | CustomAttribute | None]\n</code></pre>"},{"location":"api/#rxxxt.elements.HTMLAttributeValue","title":"HTMLAttributeValue  <code>module-attribute</code>","text":"<pre><code>HTMLAttributeValue = str | bool | int | float | CustomAttribute | None\n</code></pre>"},{"location":"api/#rxxxt.elements.HTMLElement","title":"HTMLElement","text":"<pre><code>HTMLElement(context: Context, tag: str, attributes: HTMLAttributes, content: ElementContent)\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>@fn_element\ndef HTMLElement(context: Context, tag: str, attributes: HTMLAttributes, content: ElementContent):\n  return ElementNode(context, tag, _html_attributes_to_kv(attributes), _element_content_to_ordered_nodes(context, content))\n</code></pre>"},{"location":"api/#rxxxt.elements.HTMLFragment","title":"HTMLFragment","text":"<pre><code>HTMLFragment(context: Context, content: ElementContent)\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>@fn_element\ndef HTMLFragment(context: Context, content: ElementContent):\n  return FragmentNode(context, _element_content_to_ordered_nodes(context, content))\n</code></pre>"},{"location":"api/#rxxxt.elements.HTMLVoidElement","title":"HTMLVoidElement","text":"<pre><code>HTMLVoidElement(context: Context, tag: str, attributes: HTMLAttributes)\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>@fn_element\ndef HTMLVoidElement(context: Context, tag: str, attributes: HTMLAttributes):\n  return VoidElementNode(context, tag, _html_attributes_to_kv(attributes))\n</code></pre>"},{"location":"api/#rxxxt.elements.KeyedElement","title":"KeyedElement","text":"<pre><code>KeyedElement(context: Context, key: str, element: Element)\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>@fn_element\ndef KeyedElement(context: Context, key: str, element: Element):\n  try: context = context.replace_index(key)\n  except ValueError as e: logging.debug(f\"Failed to replace index with key {key}\", e)\n  return element.tonode(context)\n</code></pre>"},{"location":"api/#rxxxt.elements.lazy_element","title":"lazy_element","text":"<pre><code>lazy_element(fn: Callable[Concatenate[Context, FNP], Element]) -&gt; Callable[FNP, Element]\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>def lazy_element(fn: Callable[Concatenate[Context, FNP], Element]) -&gt; Callable[FNP, 'Element']:\n  def _inner(context: Context, *args: FNP.args, **kwargs: FNP.kwargs) -&gt; Node:\n    return fn(context, *args, **kwargs).tonode(context)\n  return fn_element(_inner)\n</code></pre>"},{"location":"api/#rxxxt.elements.merge_attributes","title":"merge_attributes","text":"<pre><code>merge_attributes(a: HTMLAttributes, b: HTMLAttributes)\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>def merge_attributes(a: HTMLAttributes, b: HTMLAttributes):\n  return dict(_merge_attribute_items(itertools.chain(a.items(), b.items())))\n</code></pre>"},{"location":"api/#rxxxt.elements.ScriptContent","title":"ScriptContent","text":"<pre><code>ScriptContent(context: Context, script: str)\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>@fn_element\ndef ScriptContent(context: Context, script: str):\n  return TextNode(context, script.replace(\"&lt;/\", \"&lt;\\\\/\"))\n</code></pre>"},{"location":"api/#rxxxt.elements.TextElement","title":"TextElement","text":"<pre><code>TextElement(context: Context, text: str)\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>@fn_element\ndef TextElement(context: Context, text: str):\n  return TextNode(context, html.escape(text))\n</code></pre>"},{"location":"api/#rxxxt.elements.UnescapedHTMLElement","title":"UnescapedHTMLElement","text":"<pre><code>UnescapedHTMLElement(context: Context, text: str)\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>@fn_element\ndef UnescapedHTMLElement(context: Context, text: str):\n  return TextNode(context, text)\n</code></pre>"},{"location":"api/#rxxxt.elements.VEl","title":"VEl","text":""},{"location":"api/#rxxxt.elements.WithRegistered","title":"WithRegistered","text":"<pre><code>WithRegistered(context: Context, register: dict[str, Any], child: Element)\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>@fn_element\ndef WithRegistered(context: Context, register: dict[str, Any], child: Element):\n  return child.tonode(context.update_registry(register))\n</code></pre>"},{"location":"api/#rxxxt.execution.Context","title":"Context  <code>dataclass</code>","text":"<pre><code>Context(id: ContextStack, state: State, registry: dict[str, Any], config: ContextConfig, execution: Execution)\n</code></pre> <p>Classes:</p> Name Description <code>StateConsumer</code> <p>Methods:</p> Name Description <code>__hash__</code> <code>add_query_selector_event</code> <code>add_window_event</code> <code>delete_cookie</code> <code>emit</code> <code>get_header</code> <code>match_path</code> <code>navigate</code> <code>registered</code> <code>remove_query_selector_event</code> <code>remove_window_event</code> <code>replace_index</code> <code>request_update</code> <code>set_cookie</code> <code>sub</code> <code>subscribe</code> <code>update_registry</code> <code>use_websocket</code> <p>Attributes:</p> Name Type Description <code>config</code> <code>ContextConfig</code> <code>cookies</code> <code>dict[str, str]</code> <code>execution</code> <code>Execution</code> <code>id</code> <code>ContextStack</code> <code>location</code> <code>path</code> <code>query_string</code> <code>registry</code> <code>dict[str, Any]</code> <code>sid</code> <code>stack_sids</code> <code>state</code> <code>State</code> <code>update_consumer</code>"},{"location":"api/#rxxxt.execution.Context.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config: ContextConfig\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.cookies","title":"cookies  <code>property</code>","text":"<pre><code>cookies: dict[str, str]\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.execution","title":"execution  <code>instance-attribute</code>","text":"<pre><code>execution: Execution\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: ContextStack\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.location","title":"location  <code>property</code>","text":"<pre><code>location\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.path","title":"path  <code>property</code>","text":"<pre><code>path\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.query_string","title":"query_string  <code>property</code>","text":"<pre><code>query_string\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.registry","title":"registry  <code>instance-attribute</code>","text":"<pre><code>registry: dict[str, Any]\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.sid","title":"sid  <code>cached</code> <code>property</code>","text":"<pre><code>sid\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.stack_sids","title":"stack_sids  <code>property</code>","text":"<pre><code>stack_sids\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: State\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.update_consumer","title":"update_consumer  <code>cached</code> <code>property</code>","text":"<pre><code>update_consumer\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.StateConsumer","title":"StateConsumer","text":"<pre><code>StateConsumer(context: Context)\n</code></pre> <p>               Bases: <code>StateConsumer</code></p> <p>Methods:</p> Name Description <code>consume</code> <code>detach</code> <p>Attributes:</p> Name Type Description <code>context</code> Source code in <code>rxxxt/execution.py</code> <pre><code>def __init__(self, context: 'Context') -&gt; None: self.context = context\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.StateConsumer.context","title":"context  <code>instance-attribute</code>","text":"<pre><code>context = context\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.StateConsumer.consume","title":"consume","text":"<pre><code>consume(key: str, producer: Callable[[], str]) -&gt; Any\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def consume(self, key: str, producer: Callable[[], str]) -&gt; Any: self.context.request_update()\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.StateConsumer.detach","title":"detach","text":"<pre><code>detach(key: str) -&gt; Any\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def detach(self, key: str) -&gt; Any: self.context.request_update()\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def __hash__(self) -&gt; int:\n  return hash(self.id)\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.add_query_selector_event","title":"add_query_selector_event","text":"<pre><code>add_query_selector_event(selector: str, name: str, descriptor: InputEventDescriptor | InputEventDescriptorGenerator, all: bool = False)\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def add_query_selector_event(self, selector: str, name: str, descriptor: InputEventDescriptor | InputEventDescriptorGenerator, all: bool = False):\n  self._modify_query_selector_event(selector, name, descriptor, all, \"add\")\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.add_window_event","title":"add_window_event","text":"<pre><code>add_window_event(name: str, descriptor: InputEventDescriptor | InputEventDescriptorGenerator)\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def add_window_event(self, name: str, descriptor: InputEventDescriptor | InputEventDescriptorGenerator):\n  self._modify_window_event(name, descriptor, \"add\")\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.delete_cookie","title":"delete_cookie","text":"<pre><code>delete_cookie(name: str, mirror_state: bool = True)\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def delete_cookie(self, name: str, mirror_state: bool = True):\n  self.set_cookie(name=name, max_age=-1, mirror_state=False)\n  if mirror_state:\n    self.state.set_many({ \"!header;cookie\": \"; \".join(f\"{k}={v}\" for k, v in self.cookies.items() if k != name) })\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.emit","title":"emit","text":"<pre><code>emit(name: str, data: dict[str, int | float | str | bool | None])\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def emit(self, name: str, data: dict[str, int | float | str | bool | None]):\n  self.execution.add_output_event(dict(event=\"custom\", name=name, data=data))\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.get_header","title":"get_header","text":"<pre><code>get_header(name: str) -&gt; tuple[str, ...]\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def get_header(self, name: str) -&gt; tuple[str, ...]:\n  header_lines = self._get_state_str_subscribe(f\"!header;{name}\")\n  if header_lines is None: return ()\n  else: return tuple(header_lines.splitlines())\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.match_path","title":"match_path","text":"<pre><code>match_path(pattern: str, re_flags: int = IGNORECASE)\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def match_path(self, pattern: str, re_flags: int = re.IGNORECASE):\n  return match_path(pattern, self.path, re_flags)\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.navigate","title":"navigate","text":"<pre><code>navigate(location: str)\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def navigate(self, location: str):\n  is_full_url = \":\" in location # colon means full url\n  if not is_full_url: self.state.get(\"!location\").set(location)\n  self.execution.add_output_event(dict(event=\"navigate\", location=location, requires_refresh=is_full_url or None))\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.registered","title":"registered","text":"<pre><code>registered(name: str, t: type[T]) -&gt; T\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def registered(self, name: str, t: type[T]) -&gt; T:\n  if not isinstance((val:=self.registry.get(name)), t):\n    raise TypeError(f\"Invalid type in get_registered '{type(val)}'!\")\n  return val\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.remove_query_selector_event","title":"remove_query_selector_event","text":"<pre><code>remove_query_selector_event(selector: str, name: str, descriptor: InputEventDescriptor | InputEventDescriptorGenerator, all: bool = False)\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def remove_query_selector_event(self, selector: str, name: str, descriptor: InputEventDescriptor | InputEventDescriptorGenerator, all: bool = False):\n  self._modify_query_selector_event(selector, name, descriptor, all, \"remove\")\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.remove_window_event","title":"remove_window_event","text":"<pre><code>remove_window_event(name: str, descriptor: InputEventDescriptor | InputEventDescriptorGenerator)\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def remove_window_event(self, name: str, descriptor: InputEventDescriptor | InputEventDescriptorGenerator):\n  self._modify_window_event(name, descriptor, \"remove\")\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.replace_index","title":"replace_index","text":"<pre><code>replace_index(key: str)\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def replace_index(self, key: str):\n  if isinstance(self.id[-1], int): return dataclasses.replace(self, id=self.id[:-1] + (key,))\n  raise ValueError(\"No index to replace!\")\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.request_update","title":"request_update","text":"<pre><code>request_update()\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def request_update(self): self.execution.request_update(self.id)\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.set_cookie","title":"set_cookie","text":"<pre><code>set_cookie(name: str, value: str | None = None, expires: datetime | None = None, path: str | None = None, secure: bool | None = None, http_only: bool | None = None, domain: str | None = None, max_age: int | None = None, mirror_state: bool = True)\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def set_cookie(self, name: str, value: str | None = None, expires: datetime | None = None, path: str | None = None,\n              secure: bool | None = None, http_only: bool | None = None, domain: str | None = None, max_age: int | None = None, mirror_state: bool = True):\n  if not re.match(r'^[^=;, \\t\\n\\r\\f\\v]+$', name): raise ValueError(\"Invalid cookie name\")\n  if value is not None and not re.match(r'^[^;, \\t\\n\\r\\f\\v]+$', value): raise ValueError(\"Invalid value.\")\n  if domain is not None and not re.match(r'^[^;, \\t\\n\\r\\f\\v]+$', domain): raise ValueError(\"Invalid domain.\")\n  if path is not None and not re.match(r'^[^\\x00-\\x20;,\\s]+$', path): raise ValueError(\"Invalid path.\")\n\n  expires_str = None if expires is None else expires.isoformat()\n\n  self.execution.add_output_event(dict(event=\"set-cookie\", name=name, value=value, expires=expires_str, path=path, secure=secure, http_only=http_only, domain=domain, max_age=max_age))\n  if mirror_state:\n    self.state.set_many({ \"!header;cookie\": \"; \".join(f\"{k}={v}\" for k, v in (self.cookies | { name: value }).items()) })\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.sub","title":"sub","text":"<pre><code>sub(key: ContextStackKey)\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def sub(self, key: ContextStackKey): return dataclasses.replace(self, id=self.id + (key,))\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.subscribe","title":"subscribe","text":"<pre><code>subscribe(key: str)\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def subscribe(self, key: str): self.state.get(key).add_consumer(self.update_consumer)\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.update_registry","title":"update_registry","text":"<pre><code>update_registry(registry: dict[str, Any])\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def update_registry(self, registry: dict[str, Any]): return dataclasses.replace(self, registry=self.registry | registry)\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.use_websocket","title":"use_websocket","text":"<pre><code>use_websocket(websocket: bool = True)\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def use_websocket(self, websocket: bool = True): self.execution.add_output_event(dict(event=\"use-websocket\", websocket=websocket))\n</code></pre>"},{"location":"api/#rxxxt.execution.InputEventDescriptorOptions","title":"InputEventDescriptorOptions","text":"<p>               Bases: <code>BaseModel</code></p> <p>Attributes:</p> Name Type Description <code>debounce</code> <code>int | None</code> <code>default_params</code> <code>dict[str, int | float | str | bool | None] | None</code> <code>no_trigger</code> <code>bool</code> <code>prevent_default</code> <code>bool</code> <code>throttle</code> <code>int | None</code>"},{"location":"api/#rxxxt.execution.InputEventDescriptorOptions.debounce","title":"debounce  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debounce: int | None = None\n</code></pre>"},{"location":"api/#rxxxt.execution.InputEventDescriptorOptions.default_params","title":"default_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>default_params: dict[str, int | float | str | bool | None] | None = None\n</code></pre>"},{"location":"api/#rxxxt.execution.InputEventDescriptorOptions.no_trigger","title":"no_trigger  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>no_trigger: bool = False\n</code></pre>"},{"location":"api/#rxxxt.execution.InputEventDescriptorOptions.prevent_default","title":"prevent_default  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prevent_default: bool = False\n</code></pre>"},{"location":"api/#rxxxt.execution.InputEventDescriptorOptions.throttle","title":"throttle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>throttle: int | None = None\n</code></pre>"},{"location":"api/#rxxxt.execution.State","title":"State","text":"<pre><code>State()\n</code></pre> <p>Methods:</p> Name Description <code>cleanup</code> <code>delete</code> <code>destroy</code> <code>get</code> <code>get_key_values</code> <code>set_many</code> <p>Attributes:</p> Name Type Description <code>keys</code> Source code in <code>rxxxt/state.py</code> <pre><code>def __init__(self) -&gt; None:\n  self._key_states: dict[str, KeyState] = {}\n</code></pre>"},{"location":"api/#rxxxt.execution.State.keys","title":"keys  <code>property</code>","text":"<pre><code>keys\n</code></pre>"},{"location":"api/#rxxxt.execution.State.cleanup","title":"cleanup","text":"<pre><code>cleanup(inactive_prefixes: Set[str])\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def cleanup(self, inactive_prefixes: Set[str]):\n  active_keys = self._get_active_keys(inactive_prefixes)\n  inactive_keys = tuple(key for key in self._key_states.keys() if key not in active_keys)\n  for key in inactive_keys:\n    return self.delete(key)\n</code></pre>"},{"location":"api/#rxxxt.execution.State.delete","title":"delete","text":"<pre><code>delete(key: str)\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def delete(self, key: str):\n  state = self._key_states.pop(key, None)\n  if state is not None:\n    state.destroy()\n</code></pre>"},{"location":"api/#rxxxt.execution.State.destroy","title":"destroy","text":"<pre><code>destroy()\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def destroy(self):\n  for state in self._key_states.values():\n    state.destroy()\n  self._key_states.clear()\n</code></pre>"},{"location":"api/#rxxxt.execution.State.get","title":"get","text":"<pre><code>get(key: str)\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def get(self, key: str):\n  if (state := self._key_states.get(key)) is None:\n    state = KeyState(key, None)\n    self._key_states[key] = state\n  return state\n</code></pre>"},{"location":"api/#rxxxt.execution.State.get_key_values","title":"get_key_values","text":"<pre><code>get_key_values(inactive_prefixes: Set[str])\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def get_key_values(self, inactive_prefixes: Set[str]):\n  active_keys = self._get_active_keys(inactive_prefixes)\n  return { key: state.get() for key, state in self._key_states.items() if key in active_keys and state.has_value }\n</code></pre>"},{"location":"api/#rxxxt.execution.State.set_many","title":"set_many","text":"<pre><code>set_many(kvs: dict[str, str])\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def set_many(self, kvs: dict[str, str]):\n  for k, v in kvs.items(): self.get(k).set(v)\n</code></pre>"},{"location":"api/#rxxxt.helpers.JWTError","title":"JWTError","text":"<p>               Bases: <code>Exception</code></p>"},{"location":"api/#rxxxt.helpers.JWTManager","title":"JWTManager","text":"<pre><code>JWTManager(secret: bytes, max_age: timedelta, algorithm: str = 'HS512')\n</code></pre> <p>Classes:</p> Name Description <code>JWTHeader</code> <code>JWTPayloadValidations</code> <p>Methods:</p> Name Description <code>sign</code> <code>verify</code> <p>Attributes:</p> Name Type Description <code>JWTPayloadAdapter</code> Source code in <code>rxxxt/helpers.py</code> <pre><code>def __init__(self, secret: bytes, max_age: timedelta, algorithm: str = \"HS512\") -&gt; None:\n  super().__init__()\n  self._secret = secret\n  self._max_age: timedelta = max_age\n  self._algorithm = algorithm\n  self._digest = { \"HS256\": hashlib.sha256, \"HS384\": hashlib.sha384, \"HS512\": hashlib.sha512 }[algorithm]\n  self._jwt_header = _jwt_encode_json({ \"typ\": \"JWT\", \"alg\": self._algorithm }) + b\".\"\n</code></pre>"},{"location":"api/#rxxxt.helpers.JWTManager.JWTPayloadAdapter","title":"JWTPayloadAdapter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>JWTPayloadAdapter = TypeAdapter(dict[str, Any])\n</code></pre>"},{"location":"api/#rxxxt.helpers.JWTManager.JWTHeader","title":"JWTHeader","text":"<p>               Bases: <code>BaseModel</code></p> <p>Attributes:</p> Name Type Description <code>alg</code> <code>str</code> <code>typ</code> <code>Literal['JWT']</code>"},{"location":"api/#rxxxt.helpers.JWTManager.JWTHeader.alg","title":"alg  <code>instance-attribute</code>","text":"<pre><code>alg: str\n</code></pre>"},{"location":"api/#rxxxt.helpers.JWTManager.JWTHeader.typ","title":"typ  <code>instance-attribute</code>","text":"<pre><code>typ: Literal['JWT']\n</code></pre>"},{"location":"api/#rxxxt.helpers.JWTManager.JWTPayloadValidations","title":"JWTPayloadValidations","text":"<p>               Bases: <code>BaseModel</code></p> <p>Methods:</p> Name Description <code>is_valid</code> <p>Attributes:</p> Name Type Description <code>exp</code> <code>int</code>"},{"location":"api/#rxxxt.helpers.JWTManager.JWTPayloadValidations.exp","title":"exp  <code>instance-attribute</code>","text":"<pre><code>exp: int\n</code></pre>"},{"location":"api/#rxxxt.helpers.JWTManager.JWTPayloadValidations.is_valid","title":"is_valid","text":"<pre><code>is_valid()\n</code></pre> Source code in <code>rxxxt/helpers.py</code> <pre><code>def is_valid(self):\n  expires_dt = datetime.fromtimestamp(self.exp, timezone.utc)\n  return expires_dt &gt;= datetime.now(tz=timezone.utc)\n</code></pre>"},{"location":"api/#rxxxt.helpers.JWTManager.sign","title":"sign","text":"<pre><code>sign(extra_fields: dict[str, Any])\n</code></pre> Source code in <code>rxxxt/helpers.py</code> <pre><code>def sign(self, extra_fields: dict[str, Any]):\n  try:\n    expires_at = int((datetime.now(tz=timezone.utc) + self._max_age).timestamp())\n    stream = io.BytesIO()\n    _ = stream.write(self._jwt_header)\n    _ = stream.write(_jwt_encode_json({ \"exp\": expires_at, **extra_fields }))\n    signature = hmac.digest(self._secret, stream.getvalue(), self._digest)\n    _ = stream.write(b\".\")\n    _ = stream.write(_jwt_b64url_encode(signature))\n    return stream.getvalue().decode()\n  except Exception as e:\n    if not isinstance(e, JWTError): raise JWTError(e)\n    else: raise e\n</code></pre>"},{"location":"api/#rxxxt.helpers.JWTManager.verify","title":"verify","text":"<pre><code>verify(token: str)\n</code></pre> Source code in <code>rxxxt/helpers.py</code> <pre><code>def verify(self, token: str):\n  try:\n    parts = token.encode().split(b\".\")\n    if len(parts) != 3: raise JWTError(\"invalid format (expected 3 parts)\")\n\n    header = JWTManager.JWTHeader.model_validate_json(jwt_b64url_decode(parts[0]))\n    if header.alg != self._algorithm: raise JWTError(\"invalid algorithm in header\")\n\n    ref_signature = hmac.digest(self._secret, parts[0] + b\".\" + parts[1], self._digest)\n    if not hmac.compare_digest(jwt_b64url_decode(parts[2]), ref_signature):\n      raise JWTError(\"invalid JWT signature!\")\n\n    full_payload = JWTManager.JWTPayloadAdapter.validate_json(jwt_b64url_decode(parts[1]))\n    if not JWTManager.JWTPayloadValidations.model_validate(full_payload).is_valid():\n      raise JWTError(\"token expired\")\n\n    full_payload.pop(\"exp\", None)\n    return full_payload\n  except Exception as e:\n    if not isinstance(e, JWTError): raise JWTError(e)\n    else: raise e\n</code></pre>"},{"location":"api/#rxxxt.helpers.match_path","title":"match_path","text":"<pre><code>match_path(pattern: str, path: str, re_flags: int = IGNORECASE)\n</code></pre> Source code in <code>rxxxt/helpers.py</code> <pre><code>def match_path(pattern: str, path: str, re_flags: int = re.IGNORECASE):\n  return _compile_matcher(pattern, re_flags)(path)\n</code></pre>"},{"location":"api/#rxxxt.page.default_page","title":"default_page","text":"<pre><code>default_page(header: Element, content: Element, body_end: Element)\n</code></pre> Source code in <code>rxxxt/page.py</code> <pre><code>def default_page(header: Element, content: Element, body_end: Element):\n  return HTMLFragment([\n    VEl[\"!DOCTYPE\"](html=None),\n    El.html(content=[\n      El.head(content=[\n        VEl.meta(charset=\"UTF-8\"),\n        VEl.meta(name=\"viewport\", content=\"width=device-width, initial-scale=1.0\"),\n        header\n      ]),\n      El.body(content=[\n        content,\n        body_end\n      ])\n    ])\n  ])\n</code></pre>"},{"location":"api/#rxxxt.page.PageBuilder","title":"PageBuilder","text":"<pre><code>PageBuilder(page_factory: PageFactory = default_page)\n</code></pre> <p>               Bases: <code>PageFactory</code></p> <p>Methods:</p> Name Description <code>__call__</code> <code>add_body_end</code> <code>add_body_script</code> <code>add_header</code> <code>add_header_script</code> <code>add_stylesheet</code> Source code in <code>rxxxt/page.py</code> <pre><code>def __init__(self, page_factory: PageFactory = default_page) -&gt; None:\n  self._header_elements: list[Element] = []\n  self._body_end_elements: list[Element] = []\n  self._page_factory = page_factory\n</code></pre>"},{"location":"api/#rxxxt.page.PageBuilder.__call__","title":"__call__","text":"<pre><code>__call__(header: Element, content: Element, body_end: Element) -&gt; Element\n</code></pre> Source code in <code>rxxxt/page.py</code> <pre><code>def __call__(self, header: Element, content: Element, body_end: Element) -&gt; Element:\n  return self._page_factory(HTMLFragment([ header, *self._header_elements ]), content, HTMLFragment([ body_end, *self._body_end_elements ]))\n</code></pre>"},{"location":"api/#rxxxt.page.PageBuilder.add_body_end","title":"add_body_end","text":"<pre><code>add_body_end(el: Element)\n</code></pre> Source code in <code>rxxxt/page.py</code> <pre><code>def add_body_end(self, el: Element): self._body_end_elements.append(el)\n</code></pre>"},{"location":"api/#rxxxt.page.PageBuilder.add_body_script","title":"add_body_script","text":"<pre><code>add_body_script(url: str, content: ElementContent = (), **kwargs: HTMLAttributeValue)\n</code></pre> Source code in <code>rxxxt/page.py</code> <pre><code>def add_body_script(self, url: str, content: ElementContent = (), **kwargs: HTMLAttributeValue):\n  self.add_body_end(El.script(src=url, content=content, **kwargs))\n</code></pre>"},{"location":"api/#rxxxt.page.PageBuilder.add_header","title":"add_header","text":"<pre><code>add_header(el: Element)\n</code></pre> Source code in <code>rxxxt/page.py</code> <pre><code>def add_header(self, el: Element): self._header_elements.append(el)\n</code></pre>"},{"location":"api/#rxxxt.page.PageBuilder.add_header_script","title":"add_header_script","text":"<pre><code>add_header_script(url: str, content: ElementContent = (), **kwargs: HTMLAttributeValue)\n</code></pre> Source code in <code>rxxxt/page.py</code> <pre><code>def add_header_script(self, url: str, content: ElementContent = (), **kwargs: HTMLAttributeValue):\n  self.add_header(El.script(src=url, content=content, **kwargs))\n</code></pre>"},{"location":"api/#rxxxt.page.PageBuilder.add_stylesheet","title":"add_stylesheet","text":"<pre><code>add_stylesheet(url: str, **kwargs: HTMLAttributeValue)\n</code></pre> Source code in <code>rxxxt/page.py</code> <pre><code>def add_stylesheet(self, url: str, **kwargs: HTMLAttributeValue): self.add_header(VEl.link(rel=\"stylesheet\", href=url, **kwargs))\n</code></pre>"},{"location":"api/#rxxxt.page.PageFactory","title":"PageFactory","text":"<p>               Bases: <code>Protocol</code></p> <p>Methods:</p> Name Description <code>__call__</code>"},{"location":"api/#rxxxt.page.PageFactory.__call__","title":"__call__","text":"<pre><code>__call__(header: Element, content: Element, body_end: Element) -&gt; Element\n</code></pre> Source code in <code>rxxxt/page.py</code> <pre><code>def __call__(self, header: Element, content: Element, body_end: Element) -&gt; Element: ...\n</code></pre>"},{"location":"api/#rxxxt.router.Router","title":"Router","text":"<pre><code>Router()\n</code></pre> <p>               Bases: <code>ElementFactory</code></p> <p>Classes:</p> Name Description <code>RoutedComponent</code> <p>Methods:</p> Name Description <code>__call__</code> <code>add_route</code> <code>add_router</code> <code>route</code> Source code in <code>rxxxt/router.py</code> <pre><code>def __init__(self) -&gt; None:\n  self._routes: list[tuple[str, ElementFactory]] = []\n</code></pre>"},{"location":"api/#rxxxt.router.Router.RoutedComponent","title":"RoutedComponent","text":"<pre><code>RoutedComponent(routes: tuple[tuple[str, ElementFactory], ...])\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Methods:</p> Name Description <code>on_before_update</code> <code>render</code> <p>Attributes:</p> Name Type Description <code>params</code> Source code in <code>rxxxt/router.py</code> <pre><code>def __init__(self, routes: tuple[tuple[str, ElementFactory], ...]):\n  super().__init__()\n  self._routes = routes\n  self._selected_match: tuple[int, ElementFactory, dict[str, str]] | None = None\n</code></pre>"},{"location":"api/#rxxxt.router.Router.RoutedComponent.params","title":"params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>params = router_params()\n</code></pre>"},{"location":"api/#rxxxt.router.Router.RoutedComponent.on_before_update","title":"on_before_update  <code>async</code>","text":"<pre><code>on_before_update() -&gt; None\n</code></pre> Source code in <code>rxxxt/router.py</code> <pre><code>async def on_before_update(self) -&gt; None:\n  self._selected_match = self._get_current_match()\n  self.params = typing.cast(dict[str, str], dict()) if self._selected_match is None else self._selected_match[2]\n</code></pre>"},{"location":"api/#rxxxt.router.Router.RoutedComponent.render","title":"render","text":"<pre><code>render() -&gt; Element\n</code></pre> Source code in <code>rxxxt/router.py</code> <pre><code>def render(self) -&gt; Element:\n  if self._selected_match is None:\n    return El.h1(content=[\"Not found!\"])\n  else:\n    return TaggedElement(str(self._selected_match[0]), self._selected_match[1]())\n</code></pre>"},{"location":"api/#rxxxt.router.Router.__call__","title":"__call__","text":"<pre><code>__call__() -&gt; Element\n</code></pre> Source code in <code>rxxxt/router.py</code> <pre><code>def __call__(self) -&gt; Element: return Router.RoutedComponent(tuple(self._routes))\n</code></pre>"},{"location":"api/#rxxxt.router.Router.add_route","title":"add_route","text":"<pre><code>add_route(pattern: str, element_factory: ElementFactory)\n</code></pre> Source code in <code>rxxxt/router.py</code> <pre><code>def add_route(self, pattern: str, element_factory: ElementFactory): self._routes.append((pattern, element_factory))\n</code></pre>"},{"location":"api/#rxxxt.router.Router.add_router","title":"add_router","text":"<pre><code>add_router(router: Router)\n</code></pre> Source code in <code>rxxxt/router.py</code> <pre><code>def add_router(self, router: 'Router'): self._routes.extend(router._routes)\n</code></pre>"},{"location":"api/#rxxxt.router.Router.route","title":"route","text":"<pre><code>route(pattern: str)\n</code></pre> Source code in <code>rxxxt/router.py</code> <pre><code>def route(self, pattern: str):\n  def _inner(fn: ElementFactory):\n    self.add_route(pattern, fn)\n    return fn\n  return _inner\n</code></pre>"},{"location":"api/#rxxxt.router.router_params","title":"router_params","text":"<pre><code>router_params()\n</code></pre> Source code in <code>rxxxt/router.py</code> <pre><code>def router_params(): return context_state(dict[str, str], \"*rp*\")\n</code></pre>"},{"location":"api/#rxxxt.session.AppConfig","title":"AppConfig  <code>dataclass</code>","text":"<pre><code>AppConfig(enable_web_socket_state_updates: bool | None = None, disable_http_update_retry: bool | None = None)\n</code></pre> <p>Attributes:</p> Name Type Description <code>disable_http_update_retry</code> <code>bool | None</code> <code>enable_web_socket_state_updates</code> <code>bool | None</code>"},{"location":"api/#rxxxt.session.AppConfig.disable_http_update_retry","title":"disable_http_update_retry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>disable_http_update_retry: bool | None = None\n</code></pre>"},{"location":"api/#rxxxt.session.AppConfig.enable_web_socket_state_updates","title":"enable_web_socket_state_updates  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>enable_web_socket_state_updates: bool | None = None\n</code></pre>"},{"location":"api/#rxxxt.state.default_state_resolver","title":"default_state_resolver","text":"<pre><code>default_state_resolver() -&gt; JWTStateResolver\n</code></pre> <p>Creates a JWTStateResolver. Uses the environment variable <code>JWT_SECRET</code> as its secret, if set, otherwise creates a new random, temporary secret.</p> Source code in <code>rxxxt/state.py</code> <pre><code>def default_state_resolver() -&gt; JWTStateResolver:\n  \"\"\"\n  Creates a JWTStateResolver.\n  Uses the environment variable `JWT_SECRET` as its secret, if set, otherwise creates a new random, temporary secret.\n  \"\"\"\n\n  jwt_secret = os.getenv(\"JWT_SECRET\", None)\n  if jwt_secret is None: jwt_secret = secrets.token_bytes(64)\n  else: jwt_secret = jwt_secret.encode(\"utf-8\")\n  return JWTStateResolver(jwt_secret)\n</code></pre>"},{"location":"api/#rxxxt.state.JWTStateResolver","title":"JWTStateResolver","text":"<pre><code>JWTStateResolver(secret: bytes, max_age: timedelta | None = None, algorithm: str = 'HS512')\n</code></pre> <p>               Bases: <code>StateResolver</code></p> <p>Methods:</p> Name Description <code>create_token</code> <code>resolve</code> <p>Attributes:</p> Name Type Description <code>StateDataAdapter</code> Source code in <code>rxxxt/state.py</code> <pre><code>def __init__(self, secret: bytes, max_age: timedelta | None = None, algorithm: str = \"HS512\") -&gt; None:\n  super().__init__()\n  self._jwt_manager = JWTManager(secret, timedelta(days=1) if max_age is None else max_age, algorithm)\n</code></pre>"},{"location":"api/#rxxxt.state.JWTStateResolver.StateDataAdapter","title":"StateDataAdapter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StateDataAdapter = TypeAdapter(dict[str, str])\n</code></pre>"},{"location":"api/#rxxxt.state.JWTStateResolver.create_token","title":"create_token","text":"<pre><code>create_token(data: dict[str, str], old_token: str | None) -&gt; str\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def create_token(self, data: dict[str, str], old_token: str | None) -&gt; str:\n  try: return self._jwt_manager.sign({ \"d\": data })\n  except JWTError as e: raise StateResolverError(e)\n</code></pre>"},{"location":"api/#rxxxt.state.JWTStateResolver.resolve","title":"resolve","text":"<pre><code>resolve(token: str) -&gt; dict[str, str]\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def resolve(self, token: str) -&gt; dict[str, str]:\n  try:\n    payload = self._jwt_manager.verify(token)\n    return JWTStateResolver.StateDataAdapter.validate_python(payload[\"d\"])\n  except (ValidationError, JWTError) as e: raise StateResolverError(e)\n</code></pre>"},{"location":"api/#rxxxt.state.State","title":"State","text":"<pre><code>State()\n</code></pre> <p>Methods:</p> Name Description <code>cleanup</code> <code>delete</code> <code>destroy</code> <code>get</code> <code>get_key_values</code> <code>set_many</code> <p>Attributes:</p> Name Type Description <code>keys</code> Source code in <code>rxxxt/state.py</code> <pre><code>def __init__(self) -&gt; None:\n  self._key_states: dict[str, KeyState] = {}\n</code></pre>"},{"location":"api/#rxxxt.state.State.keys","title":"keys  <code>property</code>","text":"<pre><code>keys\n</code></pre>"},{"location":"api/#rxxxt.state.State.cleanup","title":"cleanup","text":"<pre><code>cleanup(inactive_prefixes: Set[str])\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def cleanup(self, inactive_prefixes: Set[str]):\n  active_keys = self._get_active_keys(inactive_prefixes)\n  inactive_keys = tuple(key for key in self._key_states.keys() if key not in active_keys)\n  for key in inactive_keys:\n    return self.delete(key)\n</code></pre>"},{"location":"api/#rxxxt.state.State.delete","title":"delete","text":"<pre><code>delete(key: str)\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def delete(self, key: str):\n  state = self._key_states.pop(key, None)\n  if state is not None:\n    state.destroy()\n</code></pre>"},{"location":"api/#rxxxt.state.State.destroy","title":"destroy","text":"<pre><code>destroy()\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def destroy(self):\n  for state in self._key_states.values():\n    state.destroy()\n  self._key_states.clear()\n</code></pre>"},{"location":"api/#rxxxt.state.State.get","title":"get","text":"<pre><code>get(key: str)\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def get(self, key: str):\n  if (state := self._key_states.get(key)) is None:\n    state = KeyState(key, None)\n    self._key_states[key] = state\n  return state\n</code></pre>"},{"location":"api/#rxxxt.state.State.get_key_values","title":"get_key_values","text":"<pre><code>get_key_values(inactive_prefixes: Set[str])\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def get_key_values(self, inactive_prefixes: Set[str]):\n  active_keys = self._get_active_keys(inactive_prefixes)\n  return { key: state.get() for key, state in self._key_states.items() if key in active_keys and state.has_value }\n</code></pre>"},{"location":"api/#rxxxt.state.State.set_many","title":"set_many","text":"<pre><code>set_many(kvs: dict[str, str])\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def set_many(self, kvs: dict[str, str]):\n  for k, v in kvs.items(): self.get(k).set(v)\n</code></pre>"},{"location":"api/#rxxxt.state.StateResolver","title":"StateResolver","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> Name Description <code>create_token</code> <code>resolve</code>"},{"location":"api/#rxxxt.state.StateResolver.create_token","title":"create_token  <code>abstractmethod</code>","text":"<pre><code>create_token(data: dict[str, str], old_token: str | None) -&gt; str | Awaitable[str]\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>@abstractmethod\ndef create_token(self, data: dict[str, str], old_token: str | None) -&gt; str | Awaitable[str]: pass\n</code></pre>"},{"location":"api/#rxxxt.state.StateResolver.resolve","title":"resolve  <code>abstractmethod</code>","text":"<pre><code>resolve(token: str) -&gt; dict[str, str] | Awaitable[dict[str, str]]\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>@abstractmethod\ndef resolve(self, token: str) -&gt; dict[str, str] | Awaitable[dict[str, str]]: pass\n</code></pre>"},{"location":"app/","title":"<code>App</code>","text":"<p>A rxxxt app is an ASGI application. It can be used, run and served like any other ASGI application.</p> <p>Apps can be created by simply passing an element factory (a function producing an element) to <code>App</code>.</p> <p>Let's write a \"Hello World!\" app: <pre><code>from rxxxt import App, El\nimport uvicorn\n\ndef element_factory():\n  return El.div(content=[\"Hello World!\"])\n\napp = App(element_factory)\nuvicorn.run(app)\n</code></pre></p> <p>Anything that returns an element, if called can be used as an <code>element_factory</code>. Like this \"Hello World\" component:</p> <pre><code>from rxxxt import App, El, Component\nimport uvicorn\n\nclass HelloWorld(Component):\n  def render(self) -&gt; Element:\n    return El.div(content=[\"Hello World\"])\n\napp = App(HelloWorld)\nuvicorn.run(app)\n</code></pre> <p>In addition to the element factory, a <code>state_resolver</code> (see State), <code>page_factory</code>, and <code>config</code> (an <code>AppConfig</code>) can be passed to <code>App</code>.</p>"},{"location":"app/#appconfig","title":"AppConfig","text":"<ul> <li><code>enable_web_socket_state_updates</code>: set to <code>True</code> when websocket pushes should include a refreshed state token so the client can keep its <code>StateResolver</code> data after the socket closes or falls back to HTTP. Leave it <code>False</code> when the websocket never needs to persist state beyond its lifetime.</li> <li><code>disable_http_update_retry</code>: set to <code>True</code> to disable resending events over HTTP when the response indicates the update is stale (new events arrived while the request was processing).</li> </ul>"},{"location":"app/#pagefactory","title":"PageFactory","text":"<p>A PageFactory is a function receiving</p> <ul> <li>a header element,</li> <li>a content element,</li> <li>and a body_end element</li> </ul> <p>returning an element that represents the html page structure.</p> <p>Take a look at the <code>default_page</code> as an example: <pre><code>def default_page(header: Element, content: Element, body_end: Element):\n  return HTMLFragment([\n    VEl[\"!DOCTYPE\"](html=None),\n    El.html(content=[\n      El.head(content=[\n        VEl.meta(charset=\"UTF-8\"),\n        VEl.meta(name=\"viewport\", content=\"width=device-width, initial-scale=1.0\"),\n        header\n      ]),\n      El.body(content=[\n        content,\n        body_end\n      ])\n    ])\n  ])\n</code></pre></p>"},{"location":"app/#pagebuilder","title":"<code>PageBuilder</code>","text":"<p>A page builder can be used to modify the contents of a page. An instance of <code>PageBuilder</code> is a <code>page_factory</code>.</p> <p>Using the utility methods, the contents of header, content and body_end can be extended. Let's add a stylesheet to the header: <pre><code>page_builder = PageBuilder()\npage_builder.add_stylesheet(\"/assets/main.css\")\napp = App(element_factory, page_factory=page_builder)\n</code></pre></p> <p>Scripts that should run after the main content is rendered can be appended through <code>add_body_end</code>. <pre><code>page_builder.add_body_end(El.script(content=[UnescapedHTMLElement(\"\"\"\nconsole.log(\"hello world\");\n\"\"\")]))\n</code></pre></p>"},{"location":"asgi/","title":"ASGI","text":"<p>rxxxt ships a set of utilities that make it easier to build and compose ASGI applications alongside <code>App</code>.</p>"},{"location":"asgi/#transport-contexts","title":"Transport contexts","text":"<ul> <li><code>TransportContext</code> exposes the raw ASGI scope, <code>receive</code> and <code>send</code> callables plus helpers for common request metadata.</li> <li><code>HTTPContext</code> builds on <code>TransportContext</code> with helpers such as <code>respond_text</code>, streaming <code>respond_file</code>, and body readers (<code>receive_json</code>, <code>receive_iter</code>, ...).</li> <li><code>WebsocketContext</code> provides <code>setup</code>, <code>receive_message</code>, <code>send_message</code>, and <code>close</code> helpers while tracking the connection state.</li> </ul>"},{"location":"asgi/#handler-decorators","title":"Handler decorators","text":"<ul> <li><code>http_handler</code> wraps a coroutine that receives <code>HTTPContext</code> and filters for HTTP scopes.</li> <li><code>websocket_handler</code> does the same for websocket scopes.</li> <li><code>routed_handler</code> pairs a simple path pattern (using <code>match_path</code>) with a handler and raises <code>ASGINextException</code> so other handlers can try when it does not match.</li> <li><code>http_not_found_handler</code> is a convenience handler that returns a plain 404 response.</li> </ul> <p>These decorators can be used with a <code>Composer</code> instance.</p>"},{"location":"asgi/#example-matching-faviconico","title":"Example: matching <code>/favicon.ico</code>","text":"<pre><code>from rxxxt.asgi import Composer, http_handler, routed_handler, http_not_found_handler\n\ncomposer = Composer()\n\n@composer.add_handler\n@http_handler\n@routed_handler(\"/favicon.ico\")\nasync def favicon(context, params):\n  return await context.respond_file(\"assets/favicon.ico\")\n\ncomposer.add_handler(http_not_found_handler)\n</code></pre> <p>If the request path does not match <code>/favicon.ico</code>, <code>routed_handler</code> raises <code>ASGINextException</code>, allowing the next handler in the <code>Composer</code> chain to run.</p>"},{"location":"asgi/#composer","title":"Composer","text":"<p><code>Composer</code> is a lightweight middleware pipeline that works using the ASGI protocol:</p> <pre><code>from rxxxt.asgi import Composer, http_handler, http_not_found_handler\n\ncomposer = Composer()\n\n@composer.add_handler\n@http_handler\ndef hello(context):\n  return context.respond_text(\"hello\")\n\ncomposer.add_handler(http_not_found_handler)\n</code></pre> <p>Handlers that cannot process a scope should raise <code>ASGINextException</code> (or call <code>context.next()</code> on a <code>TransportContext</code>). <code>Composer</code> will call the next handler in the chain. Add <code>http_not_found_handler</code> as a final fallback to send a simple 404 when no HTTP handler matches.</p>"},{"location":"asgi/#typing-helpers","title":"Typing helpers","text":"<p>The aliases <code>ASGIScope</code>, <code>ASGIFnReceive</code>, <code>ASGIFnSend</code> and <code>ASGIHandler</code> mirror the ASGI call signatures so middleware you write here works with uvicorn, Starlette/FastAPI, or any other ASGI-compatible stack.</p>"},{"location":"component/","title":"<code>Component</code>","text":"<p>Components are stateful html elements that overwrite <code>Component</code>.</p> <p>They can modify and read state, see the state documentation.</p> <p>To render a component the <code>render</code> function must be overwritten.</p> <p>A simple counter component: <pre><code>class Counter(Component):\n  count = local_state(int)\n\n  @event_handler()\n  def on_click(self):\n    self.count += 1\n\n  def render(self) -&gt; Element:\n    return El.div(onclick=self.on_click, content=[f\"Count: {self.count}\"])\n</code></pre></p> <p><code>HandleNavigate</code> can be used as an attribute helper when you only need navigation.</p>"},{"location":"component/#events","title":"Events","text":"<p>Components can receive user input events using the <code>event_handler</code> decorator.</p> <p>Like: <pre><code>@event_handler()\ndef on_click(self):\n  self.count += 1\n</code></pre></p> <p>Event handlers can receive <code>InputEventDescriptorOptions</code>.</p> <p>Parameters on event handlers can be pre-filled with <code>EventHandler.bind</code>: <pre><code>class Counter(Component):\n  count = local_state(int)\n\n  @event_handler()\n  def increase(self, amount: int):\n    self.count += amount\n\n  def render(self) -&gt; Element:\n    return El.div(content=[\n      El.button(onclick=self.increase.bind(amount=5), content=[\"Add 5\"]),\n      El.button(onclick=self.increase.bind(amount=1), content=[\"Add 1\"]),\n    ])\n</code></pre> <code>bind</code> returns a new handler instance using the provided default parameters.</p> <p>The event handlers can then be used as html attributes for the desired events. For example the, <code>onclick</code> event: <pre><code>El.div(onclick=self.on_click, content=[f\"Count: {self.count}\"])\n</code></pre></p> <p>To receive event data from an html event, you can use the <code>Annotated</code> type to specify which fields you would like to map to which function parameter.</p> <p>In the following example the event data <code>target.value</code> is selected from the <code>change</code> event of the rendered input element and passed as the <code>value</code> parameter.</p> <pre><code>from typing import Annotated\nfrom rxxxt import Component, event_handler, VEl, Element\n\nclass InputExample(Component):\n  @event_handler()\n  def on_change(self, value: Annotated[str, \"target.value\"]):\n    print(\"The user entered \", value)\n\n  def render(self) -&gt; Element:\n    return VEl.input(onchange=self.on_change, type=\"text\")\n</code></pre>"},{"location":"component/#custom-output-events","title":"Custom output events","text":"<p><code>Context.emit</code> lets a component notify the browser about arbitrary events. The event name is a string and the payload must be JSON-compatible primitives (<code>int</code>, <code>float</code>, <code>str</code>, <code>bool</code> or <code>None</code>).</p> <p>On the browser side, handlers can be registered through <code>window.rxxxt.on</code>.</p> <pre><code>from rxxxt import App, Component, Element, El, PageBuilder, UnescapedHTMLElement, event_handler\n\nclass Export(Component):\n  @event_handler()\n  def download(self):\n    self.context.emit(\"download\", {\"url\": \"https://example.com/archive.zip\", \"name\": \"archive.zip\"})\n\n  def render(self) -&gt; Element:\n    return El.button(onclick=self.download, content=[\"Download archive\"])\n\npage = PageBuilder()\npage.add_body_end(El.script(content=[\n  UnescapedHTMLElement(\"\"\"\n    rxxxt.on(\"download\", data =&gt; {\n      const link = document.createElement(\"a\");\n      link.download = data.name;\n      link.href = data.url;\n      link.style.display = \"none\";\n      document.body.appendChild(link);\n      link.click();\n      link.remove();\n    });\n  \"\"\")\n]))\n\napp = App(Export, page_factory=page)\n</code></pre> <p>Handlers can be removed with <code>window.rxxxt.off(name, handler)</code>.</p>"},{"location":"component/#background-tasks","title":"Background tasks","text":"<p>Background tasks only run when a session is persistent (using websockets).</p> <p>They can be created in two ways:</p> <ul> <li><code>add_job</code> - creates a task from a coroutine that must be run until finished</li> <li><code>add_worker</code> - creates a task from a coroutine that runs in the background until the component is destroyed. Can be cancelled at any time.</li> </ul>"},{"location":"component/#lifecycle","title":"Lifecycle","text":"<p>A component is alive as long as its parent is not updated.</p> <p>Events:</p> <ul> <li><code>on_init</code> - when the component is initialized</li> <li><code>on_before_destroy</code> - before all background tasks are destroyed</li> <li><code>on_after_destroy</code> - after all background tasks are destroyed</li> </ul>"},{"location":"component/#context","title":"Context","text":"<p>A lot of functionality that is available to components lives inside the component <code>Context</code>.</p>"},{"location":"component/#use-websocket-request-updates","title":"use websocket, request updates","text":"<ul> <li><code>use_websocket</code></li> <li><code>request_update</code></li> </ul>"},{"location":"component/#access-headers-path-query_string-navigate-setget-cookies","title":"access headers, path, query_string, navigate, set/get cookies","text":"<p>properties:</p> <ul> <li><code>cookies</code></li> <li><code>location</code></li> <li><code>path</code></li> <li><code>query_string</code></li> </ul> <p>methods:</p> <ul> <li><code>get_header</code></li> <li><code>set_cookie</code> (<code>mirror_state</code> controls whether the cookie header is updated in state)</li> <li><code>delete_cookie</code> (also honours <code>mirror_state</code>)</li> <li><code>navigate</code></li> <li><code>match_path</code></li> </ul>"},{"location":"component/#manage-subscriptions","title":"manage subscriptions","text":"<ul> <li><code>subscribe</code></li> <li><code>unsubscribe</code></li> <li><code>unsubscribe_all</code></li> </ul>"},{"location":"component/#addremove-events-to-the-window-or-elements-selected-by-a-query-selector","title":"add/remove events to the window or elements selected by a query selector","text":"<ul> <li><code>add_query_selector_event</code></li> <li><code>add_window_event</code></li> <li><code>remove_query_selector_event</code></li> <li><code>remove_window_event</code></li> </ul>"},{"location":"elements/","title":"Elements","text":"<ul> <li><code>Element</code> - Abstract base for every renderable element. Implement <code>tonode</code> to describe how the element expands in the tree.</li> <li><code>CustomAttribute</code> - Base class for special attributes that expand into real HTML attributes at render time.</li> <li><code>ElementContent</code> - Sequence of child elements or strings accepted by most element constructors.</li> <li><code>HTMLAttributeValue</code> / <code>HTMLAttributes</code> - Accepted attribute shapes for HTML elements. Non-string primitives are converted.</li> <li><code>lazy_element</code> - Wrap a factory that receives the current <code>Context</code> when the element is rendered.</li> <li><code>TextElement</code> - Escapes text so it can be safely inserted into the DOM tree.</li> <li><code>ScriptContent</code> - Wrap inline script content, escaping closing tags to prevent premature termination.</li> <li><code>ElementFactory</code> - Protocol for callables that create elements.</li> <li> <p><code>El</code> - A way to create html elements quickly.   Write <code>El.&lt;tag name&gt;</code> or <code>El[\"&lt;tag name&gt;\"]</code> to create an element with this tag name.   You may specify attributes by passing them as key values parameters. The inner content is set by specifying the list <code>content</code> with <code>str | Element</code> as children.   Example:   <pre><code># left underscores are stripped from attribute names\nEl.div(_class=\"button\", content=[\"click me\"])\n</code></pre></p> </li> <li> <p><code>VEl</code> - A way to create html void elements (like <code>input</code>, <code>meta</code>, <code>link</code> etc.) quickly.   Write <code>VEl.&lt;tag name&gt;</code> or <code>VEl[\"&lt;tag name&gt;\"]</code> to create an element with this tag name.   You may specify attributes by passing them as key values parameters. Void elements have no inner content.   <pre><code># left underscores are stripped from attribute names\nVEl.input(_type=\"text\")\n</code></pre></p> </li> <li> <p><code>UnescapedHTMLElement</code> - Use this to return raw html strings. Example: <code>UnescapedHTMLElement(\"&lt;h1&gt;Hello World&lt;/h1&gt;\")</code></p> </li> <li> <p><code>HTMLFragment</code> - To create fragments, a container for elements on the same level. Works like react fragments.</p> </li> <li><code>KeyedElement</code> - Sets the rendering key of an element.</li> <li> <p><code>WithRegistered</code> - Registeres values for its child. Intended to be used in combination with <code>self.context.registered(...)</code>.</p> </li> <li> <p><code>HTMLVoidElement</code> - long form of <code>VEl</code>, pass <code>tag: str, attributes: dict[str, str | CustomAttribute | None]</code> to the constructor</p> </li> <li><code>HTMLElement</code> - long form of <code>El</code>, pass <code>tag: str, attributes: dict[str, str | CustomAttribute | None] = {}, content: Iterable[Element | str] = (), key: str | None = None</code> to the constructor</li> <li><code>class_map</code> - Turn a <code>dict[str, bool]</code> into a space separated class string.</li> <li><code>merge_attributes</code> - Merge two attribute dictionaries, normalizing keys and joining <code>class</code> / <code>style</code> values.</li> <li><code>add_attributes</code> - Convenience wrapper to extend an attribute dict with keyword arguments via <code>merge_attributes</code>.</li> </ul>"},{"location":"path-matching/","title":"Path Matching","text":"<p><code>match_path</code> compares an incoming path against a pattern and returns a dictionary of extracted parameters when it matches, otherwise <code>None</code>.</p> <pre><code>from rxxxt import match_path\n\nif (params := match_path(\"/projects/{id}\", \"/projects/42\")):\n  print(params[\"id\"])  # -&gt; \"42\"\n</code></pre>"},{"location":"path-matching/#pattern-syntax","title":"Pattern syntax","text":"<ul> <li>Plain text segments must match exactly (case-insensitive by default).</li> <li>Named captures use <code>{name}</code> and are returned in the result dictionary.</li> <li>Appending <code>*</code> to a part (<code>{rest*}</code>) allows matching across multiple path segments.</li> <li>Anonymous captures <code>{}</code> and <code>{*}</code> match without adding a named entry.</li> </ul> <p>Examples:</p> <pre><code>match_path(\"/{name}/{id}\", \"/project/2\")\n# {'name': 'project', 'id': '2'}\n\nmatch_path(\"/{path*}\", \"/project/2\")\n# {'path': 'project/2'}\n</code></pre> <p>Part names must be valid Python identifiers (letters, digits, underscores, and not starting with a digit). Invalid identifiers raise a <code>ValueError</code>, so you get fast feedback when defining routes.</p>"},{"location":"path-matching/#flags-and-customisation","title":"Flags and customisation","text":"<p><code>match_path(pattern, path, re_flags=re.IGNORECASE)</code> accepts any <code>re</code> flag value. Pass <code>re.IGNORECASE | re.VERBOSE</code> (or others) if you need custom matching behaviour.</p>"},{"location":"path-matching/#where-it-is-used","title":"Where it is used","text":"<ul> <li><code>Router</code> relies on <code>match_path</code> to resolve routes and populate <code>router_params</code>.</li> <li><code>routed_handler</code> layers the same pattern matching onto ASGI handlers.</li> </ul>"},{"location":"router/","title":"<code>Router</code>","text":"<p>Routers can be used to match against url paths and extract parameters. A router is an <code>ElementFactory</code> and can be passed directly to the app.</p>"},{"location":"router/#adding-routes","title":"Adding Routes","text":"<p>Routes can be added with <code>add_route</code> supplying the pattern and the element factory for this route. Alternatively routes can be added using decorators.</p> <p><code>add_router</code> merges the routes of another <code>Router</code> instance, which is useful when building feature modules.</p> <pre><code>from rxxxt import Router, El, App\nimport uvicorn\n\nrouter = Router()\n\nchild = Router()\nchild.add_route(\"/child\", lambda: El.div(content=[\"child\"]))\nrouter.add_router(child)\n\ndef hello_factory():\n  return El.div(content=[\"hello\"])\n\nrouter.add_route(\"/hello\", hello_factory)\n\n@router.route(\"/world\")\ndef world_factory():\n  return El.div(content=[\"world\"])\n\napp = App(router)\nuvicorn.run(app)\n</code></pre>"},{"location":"router/#route-patterns","title":"Route Patterns","text":"<p>Routing uses <code>match_path</code>.</p>"},{"location":"router/#accessing-parameters","title":"Accessing Parameters","text":"<p>To access the route parameters the <code>router_params</code> class field can be used inside components.</p> <pre><code>from rxxxt import Router, router_params, Component, event_handler, El, Element, App\nimport uvicorn\n\nclass ShowPath(Component):\n  params = router_params()\n\n  @event_handler()\n  def nav_hello(self): self.context.navigate(\"/hello\")\n\n  @event_handler()\n  def nav_world(self): self.context.navigate(\"/world\")\n\n  def render(self) -&gt; Element:\n    return El.div(content=[\n      El.div(content=[f\"Word: {self.params.get('word', '-')}\"]),\n      El.button(onclick=self.nav_hello, content=[\"nav 'hello'\"]),\n      El.button(onclick=self.nav_world, content=[\"nav 'world'\"]),\n    ])\n\nrouter = Router()\nrouter.add_route(\"/{word}\", ShowPath)\n\napp = App(router)\nuvicorn.run(app)\n</code></pre>"},{"location":"state/","title":"State","text":"<p>State is organized as a key-value store. In order to associate a state with a session accross multiple requests, a token is created. The next request of the same session must include the state token, which will then be used to resolve the associated state.</p> <p>By default the <code>JWTStateResolver</code> is used, which transforms the state into a JWT token, making the server side entirely stateless.</p> <p>This is handled by the <code>StateResolver</code> of the <code>App</code> (default: <code>default_state_resolver</code>).</p>"},{"location":"state/#conventions","title":"Conventions","text":"<p>To handle the livetime of state prefixes are used.</p> <ul> <li>no prefix is global state</li> <li><code>#</code> prefix is temporary state, which will be discarded if no longer used</li> <li><code>!</code> prefix is protocol state, which holds headers and the location (path + query string). This data will always be present for the components, but is only associated with the token, if actually used</li> </ul>"},{"location":"state/#with-components","title":"with Components","text":"<p>There are helpers for defining and using states in Components. These let you define state variables and access them almost like they were native fields. Descriptors such as <code>local_state</code> return the raw value, whereas the <code>_box</code> variants hand you a <code>StateBox</code>. A box exposes a <code>.value</code> attribute so you can both read and assign; writing to <code>.value</code> immediately schedules an update, while mutating the referenced object in-place requires an explicit <code>.update()</code> afterwards to keep dependants in sync.</p> <ol> <li><code>local_state</code> - which is confined to a single component instance <pre><code>from typing import Annotated\nfrom rxxxt import Component, event_handler, VEl, Element, local_state\n\nclass InputExample(Component):\n  text = local_state(str)\n\n  @event_handler(debounce=500)\n  def on_input(self, value: Annotated[str, \"target.value\"]):\n    self.text = value\n\n  def render(self) -&gt; Element:\n    return VEl.input(oninput=self.on_input, type=\"text\", value=self.text)\n</code></pre></li> <li><code>global_state</code> - which is shared accross the entire application <pre><code>from typing import Annotated\nfrom rxxxt import Component, event_handler, VEl, Element, global_state\n\nclass InputExample(Component):\n  text = global_state(str)\n\n  @event_handler(debounce=500)\n  def on_input(self, value: Annotated[str, \"target.value\"]):\n    self.text = value\n\n  def render(self) -&gt; Element:\n    return VEl.input(oninput=self.on_input, type=\"text\", value=self.text)\n</code></pre></li> <li><code>context_state</code> - which is shared across components down the tree from the first component that uses it <pre><code>from typing import Annotated\nfrom rxxxt import Component, Element, event_handler, VEl, El, context_state\n\nclass Parent(Component):\n  text = context_state(str)\n\n  @event_handler()\n  def on_input(self, value: Annotated[str, \"target.value\"]):\n    self.text = value\n\n  def render(self) -&gt; Element:\n    return El.div(content=[\n      VEl.input(oninput=self.on_input, type=\"text\", value=self.text),\n      Child(),\n    ])\n\nclass Child(Component):\n  text = context_state(str)\n\n  def render(self) -&gt; Element:\n    return El.div(content=[f\"Shared text: {self.text}\"])\n</code></pre></li> <li><code>local_state_box</code> - which is confined to a single component instance, but requires manual updates <pre><code>from rxxxt import Component, Element, event_handler, El, local_state_box\n\nclass Counter(Component):\n  count = local_state_box(int)\n\n  @event_handler()\n  def increment(self):\n    self.count.value += 1  # assigning to value triggers an update automatically\n\n  def render(self) -&gt; Element:\n    return El.div(content=[\n      El.button(onclick=self.increment, content=[\"Add one\"]),\n      El.span(content=[f\"Count: {self.count.value}\"]),\n    ])\n</code></pre></li> <li><code>global_state_box</code> - which is shared accross the entire application, but requires manual updates <pre><code>from typing import Annotated\nfrom rxxxt import Component, event_handler, VEl, Element, global_state_box\n\nclass InputExample(Component):\n  text = global_state_box(str)\n\n  @event_handler(debounce=500)\n  def on_input(self, value: Annotated[str, \"target.value\"]):\n    self.text.value = value  # simple assignments propagate automatically\n\n  def render(self) -&gt; Element:\n    return VEl.input(oninput=self.on_input, type=\"text\", value=self.text.value)\n</code></pre></li> <li><code>context_state_box</code> - which is shared across components down the tree from the first component that uses it, but requires manual updates <pre><code>from rxxxt import Component, Element, context_state_box, El, event_handler\n\ndef default_settings() -&gt; dict[str, int]:\n  return {\"visits\": 0}\n\nclass SharedData(Component):\n  settings = context_state_box(default_settings)\n\n  @event_handler()\n  def add_visit(self):\n    self.settings.value[\"visits\"] += 1\n    self.settings.update()  # notify that nested data changed in-place\n\n  def render(self) -&gt; Element:\n    return El.div(content=[\n      El.button(onclick=self.add_visit, content=[\"Add visit\"]),\n      El.span(content=[f\"Visits: {self.settings.value['visits']}\"]),\n    ])\n</code></pre></li> </ol>"}]}