{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"rxxxt (R-3-X-T)","text":"<p>A library to build server side rendered, reactive web applications in python.</p> <p>1 dependency (pydantic).</p> <p>Features:</p> <ul> <li>stateless (HTTP) and stateful (websocket) sessions</li> <li>server to client updates</li> <li>integrated state management</li> <li>background workers</li> <li>routing and navigation</li> <li>partial page updates</li> <li>more...</li> </ul> <p>Have a look at the Getting Started guide or check out the full documentation.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install rxxxt\n</code></pre> <p>If you want to run the application, you will have to install an ASGI web server like uvicorn (with <code>[standard]</code> to allow for websockets) as well: <pre><code>pip install rxxxt uvicorn[standard]\n</code></pre></p>"},{"location":"#usage","title":"Usage","text":"<p><pre><code>import uvicorn\nfrom rxxxt import Component, El, Element, App, local_state\n\nclass Counter(Component):\n  count = local_state(int)\n\n  def on_click(self):\n    self.count += 1\n\n  def render(self) -&gt; Element:\n    return El.div(onclick=self.on_click, content=[f\"Count: {self.count}\"])\n\napp = App(Counter)\nuvicorn.run(app)\n</code></pre> result.webm</p>"},{"location":"#usage-with-fastapi","title":"Usage with FastAPI","text":"<pre><code>import uvicorn\nfrom fastapi import FastAPI, Response\nfrom rxxxt import local_state, Component, El, Element, App, PageBuilder, VEl\n\nclass Counter(Component):\n  count = local_state(int)\n\n  def on_click(self):\n    self.count += 1\n\n  def render(self) -&gt; Element:\n    return El.div(onclick=self.on_click, content=[f\"Count: {self.count}\"])\n\nserver = FastAPI()\n\n@server.get(\"/main.css\")\ndef get_css():\n  return Response(\"body { margin: 0; font-family: sans-serif; }\", media_type=\"text/css\")\n\npage_builder = PageBuilder()\npage_builder.add_header(VEl.link(rel=\"stylesheet\", href=\"/main.css\"))\n\napp = App(Counter, page_factory=page_builder)\nserver.mount(\"/\", app)\nuvicorn.run(server)\n</code></pre>"},{"location":"#notes","title":"Notes","text":"<ul> <li>after restarting python, your browser session will stop working (until you refresh), because your old state has been invalidated. Make sure to set <code>JWT_SECRET</code> to avoid this.</li> </ul>"},{"location":"api/","title":"API","text":""},{"location":"api/#rxxxt.app.App","title":"App","text":"<pre><code>App(content: ElementFactory, state_resolver: StateResolver | None = None, page_factory: PageFactory = default_page, config: AppConfig | None = None)\n</code></pre> <p>Methods:</p> Name Description <code>__call__</code> Source code in <code>rxxxt/app.py</code> <pre><code>def __init__(self, content: ElementFactory, state_resolver: StateResolver | None = None, page_factory: PageFactory = default_page, \\\n    config: AppConfig | None = None) -&gt; None:\n  self._content = content\n  self._page_factory: PageFactory = page_factory\n  self._state_resolver = state_resolver or default_state_resolver()\n  self._composer = Composer()\n  self._config = config or AppConfig()\n  _ = self._composer.add_handler(http_handler(routed_handler(\"/rxxxt-client.js\")(self._http_static_rxxxt_client_js)))\n  _ = self._composer.add_handler(http_handler(self._http_post_session))\n  _ = self._composer.add_handler(http_handler(self._http_get_session))\n  _ = self._composer.add_handler(websocket_handler(self._ws_session))\n  _ = self._composer.add_handler(http_not_found_handler)\n</code></pre>"},{"location":"api/#rxxxt.app.App.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(scope: ASGIScope, receive: ASGIFnReceive, send: ASGIFnSend) -&gt; Any\n</code></pre> Source code in <code>rxxxt/app.py</code> <pre><code>async def __call__(self, scope: ASGIScope, receive: ASGIFnReceive, send: ASGIFnSend) -&gt; Any:\n  return await self._composer(scope, receive, send)\n</code></pre>"},{"location":"api/#rxxxt.asgi.ASGIFnReceive","title":"ASGIFnReceive  <code>module-attribute</code>","text":"<pre><code>ASGIFnReceive = Callable[[], Awaitable[MutableMapping[str, Any]]]\n</code></pre>"},{"location":"api/#rxxxt.asgi.ASGIFnSend","title":"ASGIFnSend  <code>module-attribute</code>","text":"<pre><code>ASGIFnSend = Callable[[MutableMapping[str, Any]], Awaitable[Any]]\n</code></pre>"},{"location":"api/#rxxxt.asgi.ASGIHandler","title":"ASGIHandler  <code>module-attribute</code>","text":"<pre><code>ASGIHandler = Callable[[ASGIScope, ASGIFnReceive, ASGIFnSend], Awaitable[Any]]\n</code></pre>"},{"location":"api/#rxxxt.asgi.ASGINextException","title":"ASGINextException","text":"<p>               Bases: <code>Exception</code></p>"},{"location":"api/#rxxxt.asgi.ASGIScope","title":"ASGIScope  <code>module-attribute</code>","text":"<pre><code>ASGIScope = MutableMapping[str, Any]\n</code></pre>"},{"location":"api/#rxxxt.asgi.Composer","title":"Composer","text":"<pre><code>Composer()\n</code></pre> <p>Methods:</p> Name Description <code>__call__</code> <code>add_handler</code> Source code in <code>rxxxt/asgi.py</code> <pre><code>def __init__(self) -&gt; None:\n  self._handlers: list[ASGIHandler] = []\n</code></pre>"},{"location":"api/#rxxxt.asgi.Composer.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(scope: ASGIScope, receive: ASGIFnReceive, send: ASGIFnSend) -&gt; Any\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def __call__(self, scope: ASGIScope, receive: ASGIFnReceive, send: ASGIFnSend) -&gt; Any:\n  try:\n    for handler in self._handlers:\n      try: return await handler(scope, receive, send)\n      except ASGINextException: pass\n  except asyncio.CancelledError: raise\n  except BaseException as e:\n    Composer._error_count += 1\n    if Composer._error_count == 1:\n      print(\"ERROR during an ASGI request. Enable logging by calling `import logging; logging.basicConfig(level=logging.DEBUG)` at startup.\", file=sys.stderr)\n    logging.debug(\"Unhandled exception during a request\", exc_info=True, stack_info=True)\n    if scope[\"type\"] == \"websocket\":\n      return await self._ws_error_handler(WebsocketContext(scope, receive, send), e)\n    if scope[\"type\"] == \"http\":\n      return await self._http_error_handler(HTTPContext(scope, receive, send), e)\n</code></pre>"},{"location":"api/#rxxxt.asgi.Composer.add_handler","title":"add_handler","text":"<pre><code>add_handler(handler: ASGIHandler)\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>def add_handler(self, handler: ASGIHandler):\n  self._handlers.append(handler)\n  return handler\n</code></pre>"},{"location":"api/#rxxxt.asgi.http_handler","title":"http_handler","text":"<pre><code>http_handler(fn: Callable[[HTTPContext], Awaitable[Any]])\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>def http_handler(fn: Callable[[HTTPContext], Awaitable[Any]]):\n  async def _inner(scope: ASGIScope, receive: ASGIFnReceive, send: ASGIFnSend) -&gt; Any:\n    if scope[\"type\"] != \"http\": raise ASGINextException()\n    return await fn(HTTPContext(scope, receive, send))\n  return _inner\n</code></pre>"},{"location":"api/#rxxxt.asgi.http_not_found_handler","title":"http_not_found_handler  <code>async</code>","text":"<pre><code>http_not_found_handler(context: HTTPContext)\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>@http_handler\nasync def http_not_found_handler(context: HTTPContext):\n  await context.respond_text(\"not found\", 404)\n</code></pre>"},{"location":"api/#rxxxt.asgi.HTTPContext","title":"HTTPContext","text":"<pre><code>HTTPContext(scope: ASGIScope, receive: ASGIFnReceive, send: ASGIFnSend)\n</code></pre> <p>               Bases: <code>TransportContext</code></p> <p>Methods:</p> Name Description <code>add_response_headers</code> <code>receive_bytes</code> <code>receive_iter</code> <code>receive_json</code> <code>receive_json_raw</code> <code>receive_text</code> <code>respond_file</code> <code>respond_text</code> <code>response_body</code> <code>response_start</code> <p>Attributes:</p> Name Type Description <code>method</code> Source code in <code>rxxxt/asgi.py</code> <pre><code>def __init__(self, scope: ASGIScope, receive: ASGIFnReceive, send: ASGIFnSend) -&gt; None:\n  super().__init__(scope, receive, send)\n  self._response_headers: list[tuple[BytesLike, BytesLike]] = []\n</code></pre>"},{"location":"api/#rxxxt.asgi.HTTPContext.method","title":"method  <code>property</code>","text":"<pre><code>method\n</code></pre>"},{"location":"api/#rxxxt.asgi.HTTPContext.add_response_headers","title":"add_response_headers","text":"<pre><code>add_response_headers(headers: ASGIHeaders)\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>def add_response_headers(self, headers: ASGIHeaders): self._response_headers.extend(headers)\n</code></pre>"},{"location":"api/#rxxxt.asgi.HTTPContext.receive_bytes","title":"receive_bytes  <code>async</code>","text":"<pre><code>receive_bytes() -&gt; bytes\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def receive_bytes(self) -&gt; bytes:\n  stream = io.BytesIO()\n  async for chunk in self.receive_iter():\n    _ = stream.write(chunk)\n  return stream.getvalue()\n</code></pre>"},{"location":"api/#rxxxt.asgi.HTTPContext.receive_iter","title":"receive_iter  <code>async</code>","text":"<pre><code>receive_iter() -&gt; AsyncGenerator[bytes, Any]\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def receive_iter(self) -&gt; AsyncGenerator[bytes, Any]:\n  while True:\n    event = await self.receive()\n    event_type = event.get(\"type\")\n    if event_type == \"http.request\":\n      yield event.get(\"body\", b\"\")\n      if not event.get(\"more_body\", False): return\n    elif event_type == \"http.disconnect\": return\n</code></pre>"},{"location":"api/#rxxxt.asgi.HTTPContext.receive_json","title":"receive_json  <code>async</code>","text":"<pre><code>receive_json()\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def receive_json(self): return json.loads(await self.receive_json_raw())\n</code></pre>"},{"location":"api/#rxxxt.asgi.HTTPContext.receive_json_raw","title":"receive_json_raw  <code>async</code>","text":"<pre><code>receive_json_raw()\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def receive_json_raw(self): return await self.receive_text({ \"application/json\" })\n</code></pre>"},{"location":"api/#rxxxt.asgi.HTTPContext.receive_text","title":"receive_text  <code>async</code>","text":"<pre><code>receive_text(allowed_mime_types: Iterable[str])\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def receive_text(self, allowed_mime_types: Iterable[str]):\n  allowed_mime_types = allowed_mime_types if isinstance(allowed_mime_types, set) else set(allowed_mime_types)\n  mime_type, ct_params = self.content_type\n  if mime_type not in allowed_mime_types: raise ValueError(f\"Mime type '{mime_type}' is not in allowed types!\")\n  charset = ct_params.get(\"charset\", \"utf-8\")\n  try: decoder = codecs.getdecoder(charset)\n  except LookupError: raise ValueError(\"Invalid content-type encoding!\")\n  data = await self.receive_bytes()\n  return decoder(data, \"ignore\")[0]\n</code></pre>"},{"location":"api/#rxxxt.asgi.HTTPContext.respond_file","title":"respond_file  <code>async</code>","text":"<pre><code>respond_file(path: str | Path, mime_type: str | None = None, handle_404: bool = False, use_last_modified: bool = False)\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def respond_file(self, path: str | pathlib.Path, mime_type: str | None = None, handle_404: bool = False, use_last_modified: bool = False):\n  mime_type = mime_type or mimetypes.guess_type(path)[0]\n  if mime_type is None: raise ValueError(\"Unknown mime type!\")\n  ppath = pathlib.Path(path)\n  if handle_404 and not ppath.exists():\n    return await self.respond_text(\"not found\", 404)\n\n  with open(ppath, \"rb\") as fd:\n    fd_stat = os.stat(fd.fileno())\n\n    if use_last_modified:\n      last_modified = formatdate(fd_stat.st_mtime, usegmt=True).encode()\n      self.add_response_headers([ (b\"Last-Modified\", last_modified) ])\n      if (last_modified,) == self.headers.get(\"If-Modified-Since\", None):\n        await self.response_start(304)\n        await self.response_body(b\"\", False)\n        return\n\n    self.add_response_headers(content_headers(fd_stat.st_size, mime_type))\n    await self.response_start(200)\n    while len(data := fd.read(1_000_000)) != 0:\n      await self.response_body(data, fd.tell() != fd_stat.st_size)\n</code></pre>"},{"location":"api/#rxxxt.asgi.HTTPContext.respond_text","title":"respond_text  <code>async</code>","text":"<pre><code>respond_text(text: str, status: int = 200, mime_type: str = 'text/plain')\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def respond_text(self, text: str, status: int = 200, mime_type: str = \"text/plain\"):\n  data = text.encode(\"utf-8\")\n  self.add_response_headers(content_headers(len(data), mime_type + \"; charset=utf-8\"))\n  await self.response_start(status)\n  await self.response_body(data, False)\n</code></pre>"},{"location":"api/#rxxxt.asgi.HTTPContext.response_body","title":"response_body  <code>async</code>","text":"<pre><code>response_body(data: BytesLike, more_body: bool)\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def response_body(self, data: BytesLike, more_body: bool):\n  await self.send({\n    \"type\": \"http.response.body\",\n    \"body\": data,\n    \"more_body\": more_body\n  })\n</code></pre>"},{"location":"api/#rxxxt.asgi.HTTPContext.response_start","title":"response_start  <code>async</code>","text":"<pre><code>response_start(status: int, trailers: bool = False)\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def response_start(self, status: int, trailers: bool = False):\n  await self.send({\n    \"type\": \"http.response.start\",\n    \"status\": status,\n    \"headers\": self._response_headers,\n    \"trailers\": trailers\n  })\n</code></pre>"},{"location":"api/#rxxxt.asgi.routed_handler","title":"routed_handler","text":"<pre><code>routed_handler(pattern: str)\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>def routed_handler(pattern: str):\n  def _inner(fn: Callable[[CTXT, dict[str, str]], Awaitable[Any]]) -&gt; Callable[[CTXT], Awaitable[Any]]:\n    async def _inner_inner(context: CTXT) -&gt; Any:\n      if (match:=match_path(pattern, context.path)) is None: context.next()\n      return await fn(context, match)\n    return _inner_inner\n  return _inner\n</code></pre>"},{"location":"api/#rxxxt.asgi.TransportContext","title":"TransportContext","text":"<pre><code>TransportContext(scope: ASGIScope, receive: ASGIFnReceive, send: ASGIFnSend)\n</code></pre> <p>Methods:</p> Name Description <code>next</code> <p>Attributes:</p> Name Type Description <code>content_type</code> <code>fullpath</code> <code>headers</code> <code>location</code> <code>path</code> <code>query_string</code> <code>str | None</code> <code>receive</code> <code>scope</code> <code>send</code> Source code in <code>rxxxt/asgi.py</code> <pre><code>def __init__(self, scope: ASGIScope, receive: ASGIFnReceive, send: ASGIFnSend) -&gt; None:\n  self.scope = scope\n  self.receive = receive\n  self.send = send\n</code></pre>"},{"location":"api/#rxxxt.asgi.TransportContext.content_type","title":"content_type  <code>cached</code> <code>property</code>","text":"<pre><code>content_type\n</code></pre>"},{"location":"api/#rxxxt.asgi.TransportContext.fullpath","title":"fullpath  <code>property</code>","text":"<pre><code>fullpath\n</code></pre>"},{"location":"api/#rxxxt.asgi.TransportContext.headers","title":"headers  <code>cached</code> <code>property</code>","text":"<pre><code>headers\n</code></pre>"},{"location":"api/#rxxxt.asgi.TransportContext.location","title":"location  <code>property</code>","text":"<pre><code>location\n</code></pre>"},{"location":"api/#rxxxt.asgi.TransportContext.path","title":"path  <code>property</code>","text":"<pre><code>path\n</code></pre>"},{"location":"api/#rxxxt.asgi.TransportContext.query_string","title":"query_string  <code>property</code>","text":"<pre><code>query_string: str | None\n</code></pre>"},{"location":"api/#rxxxt.asgi.TransportContext.receive","title":"receive  <code>instance-attribute</code>","text":"<pre><code>receive = receive\n</code></pre>"},{"location":"api/#rxxxt.asgi.TransportContext.scope","title":"scope  <code>instance-attribute</code>","text":"<pre><code>scope = scope\n</code></pre>"},{"location":"api/#rxxxt.asgi.TransportContext.send","title":"send  <code>instance-attribute</code>","text":"<pre><code>send = send\n</code></pre>"},{"location":"api/#rxxxt.asgi.TransportContext.next","title":"next","text":"<pre><code>next()\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>def next(self): raise ASGINextException()\n</code></pre>"},{"location":"api/#rxxxt.asgi.websocket_handler","title":"websocket_handler","text":"<pre><code>websocket_handler(fn: Callable[[WebsocketContext], Awaitable[Any]])\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>def websocket_handler(fn: Callable[[WebsocketContext], Awaitable[Any]]):\n  async def _inner(scope: ASGIScope, receive: ASGIFnReceive, send: ASGIFnSend) -&gt; Any:\n    if scope[\"type\"] != \"websocket\": raise ASGINextException()\n    return await fn(WebsocketContext(scope, receive, send))\n  return _inner\n</code></pre>"},{"location":"api/#rxxxt.asgi.WebsocketContext","title":"WebsocketContext","text":"<pre><code>WebsocketContext(scope: ASGIScope, receive: ASGIFnReceive, send: ASGIFnSend)\n</code></pre> <p>               Bases: <code>TransportContext</code></p> <p>Methods:</p> Name Description <code>close</code> <code>receive_message</code> <code>send_message</code> <code>setup</code> <p>Attributes:</p> Name Type Description <code>connected</code> Source code in <code>rxxxt/asgi.py</code> <pre><code>def __init__(self, scope: ASGIScope, receive: ASGIFnReceive, send: ASGIFnSend) -&gt; None:\n  super().__init__(scope, receive, send)\n  self._connected = True\n</code></pre>"},{"location":"api/#rxxxt.asgi.WebsocketContext.connected","title":"connected  <code>property</code>","text":"<pre><code>connected\n</code></pre>"},{"location":"api/#rxxxt.asgi.WebsocketContext.close","title":"close  <code>async</code>","text":"<pre><code>close(code: int = 1000, reason: str = 'Normal Closure')\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def close(self, code: int = 1000, reason: str = \"Normal Closure\"):\n  await self.send({ \"type\": \"websocket.close\", \"code\": code, \"reason\": reason })\n  self._connected = False\n</code></pre>"},{"location":"api/#rxxxt.asgi.WebsocketContext.receive_message","title":"receive_message  <code>async</code>","text":"<pre><code>receive_message() -&gt; BytesLike | str\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def receive_message(self) -&gt; BytesLike | str:\n  while self._connected:\n    event = await self.receive()\n    if event[\"type\"] == \"websocket.disconnect\":\n      self._connected = False\n      raise ConnectionError(\"Connection closed!\")\n    elif event[\"type\"] == \"websocket.receive\":\n      return event.get(\"bytes\", event.get(\"text\"))\n  raise ConnectionError(\"Connection closed!\")\n</code></pre>"},{"location":"api/#rxxxt.asgi.WebsocketContext.send_message","title":"send_message  <code>async</code>","text":"<pre><code>send_message(data: str | BytesLike)\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def send_message(self, data: str | BytesLike):\n  if not self._connected: raise ConnectionError(\"Not connected!\")\n  event: dict[str, Any] = { \"type\": \"websocket.send\", \"bytes\": None, \"text\": None }\n  if isinstance(data, str): event[\"text\"] = data\n  else: event[\"bytes\"] = data\n  await self.send(event)\n</code></pre>"},{"location":"api/#rxxxt.asgi.WebsocketContext.setup","title":"setup  <code>async</code>","text":"<pre><code>setup(headers: ASGIHeaders = (), subprotocol: str | None = None)\n</code></pre> Source code in <code>rxxxt/asgi.py</code> <pre><code>async def setup(self, headers: ASGIHeaders = (), subprotocol: str | None = None):\n  event = await self.receive()\n  if event[\"type\"] != \"websocket.connect\": raise ConnectionError(\"Did not receive connect event!\")\n  await self.send({ \"type\": \"websocket.accept\", \"subprotocol\": subprotocol, \"headers\": [ (name.lower(), value) for name, value in headers ] })\n</code></pre>"},{"location":"api/#rxxxt.component.Component","title":"Component","text":"<pre><code>Component()\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Methods:</p> Name Description <code>add_job</code> <p>Runs a background job until completion. Only runs when the session is persistent.</p> <code>add_worker</code> <p>Runs a background worker, which may be cancelled at any time. Only runs when the session is persistent.</p> <code>lc_destroy</code> <code>lc_init</code> <code>lc_render</code> <code>on_after_destroy</code> <code>on_after_update</code> <code>on_before_destroy</code> <code>on_before_update</code> <code>on_init</code> <code>render</code> <code>tonode</code> <p>Attributes:</p> Name Type Description <code>context</code> <code>Context</code> Source code in <code>rxxxt/component.py</code> <pre><code>def __init__(self) -&gt; None:\n  super().__init__()\n  self.context: Context\n  self._worker_tasks: list[asyncio.Task[Any]] = []\n  self._job_tasks: list[asyncio.Task[Any]] = []\n</code></pre>"},{"location":"api/#rxxxt.component.Component.context","title":"context  <code>instance-attribute</code>","text":"<pre><code>context: Context\n</code></pre>"},{"location":"api/#rxxxt.component.Component.add_job","title":"add_job","text":"<pre><code>add_job(a: Coroutine[Any, Any, Any])\n</code></pre> <p>Runs a background job until completion. Only runs when the session is persistent. args:   a: Coroutine - the coroutine that should be run</p> Source code in <code>rxxxt/component.py</code> <pre><code>def add_job(self, a: Coroutine[Any, Any, Any]):\n  \"\"\"\n  Runs a background job until completion. Only runs when the session is persistent.\n  args:\n    a: Coroutine - the coroutine that should be run\n  \"\"\"\n  if self.context.config.persistent:\n    self._worker_tasks.append(asyncio.create_task(a))\n  else: a.close()\n</code></pre>"},{"location":"api/#rxxxt.component.Component.add_worker","title":"add_worker","text":"<pre><code>add_worker(a: Coroutine[Any, Any, Any])\n</code></pre> <p>Runs a background worker, which may be cancelled at any time. Only runs when the session is persistent. args:   a: Coroutine - the coroutine that should be run</p> Source code in <code>rxxxt/component.py</code> <pre><code>def add_worker(self, a: Coroutine[Any, Any, Any]):\n  \"\"\"\n  Runs a background worker, which may be cancelled at any time. Only runs when the session is persistent.\n  args:\n    a: Coroutine - the coroutine that should be run\n  \"\"\"\n  if self.context.config.persistent:\n    self._worker_tasks.append(asyncio.create_task(a))\n  else: a.close()\n</code></pre>"},{"location":"api/#rxxxt.component.Component.lc_destroy","title":"lc_destroy  <code>async</code>","text":"<pre><code>lc_destroy() -&gt; None\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>async def lc_destroy(self) -&gt; None:\n  await to_awaitable(self.on_before_destroy)\n  if len(self._job_tasks) &gt; 0:\n    try: _ = await asyncio.wait(self._job_tasks)\n    except asyncio.CancelledError: pass\n    self._job_tasks.clear()\n  if len(self._worker_tasks) &gt; 0:\n    for t in self._worker_tasks: _ = t.cancel()\n    try: _ = await asyncio.wait(self._worker_tasks)\n    except asyncio.CancelledError: pass\n    self._worker_tasks.clear()\n  await to_awaitable(self.on_after_destroy)\n</code></pre>"},{"location":"api/#rxxxt.component.Component.lc_init","title":"lc_init  <code>async</code>","text":"<pre><code>lc_init(context: Context) -&gt; None\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>async def lc_init(self, context: Context) -&gt; None:\n  if hasattr(self, \"context\"):\n    raise asyncio.InvalidStateError(\"Context already present, you must not use the instance of a component in twice.\")\n  self.context = context\n  await to_awaitable(self.on_init)\n</code></pre>"},{"location":"api/#rxxxt.component.Component.lc_render","title":"lc_render  <code>async</code>","text":"<pre><code>lc_render() -&gt; Element\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>async def lc_render(self) -&gt; Element:\n  await to_awaitable(self.on_before_update)\n  el = await to_awaitable(self.render)\n  try: self.context.execution.pending_updates.remove(self.context.id) # NOTE: remove any update that was requested during render\n  except KeyError: pass\n  await to_awaitable(self.on_after_update)\n  return el\n</code></pre>"},{"location":"api/#rxxxt.component.Component.on_after_destroy","title":"on_after_destroy","text":"<pre><code>on_after_destroy() -&gt; None | Awaitable[None]\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def on_after_destroy(self) -&gt; None | Awaitable[None]: ...\n</code></pre>"},{"location":"api/#rxxxt.component.Component.on_after_update","title":"on_after_update","text":"<pre><code>on_after_update() -&gt; None | Awaitable[None]\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def on_after_update(self) -&gt; None | Awaitable[None]: ...\n</code></pre>"},{"location":"api/#rxxxt.component.Component.on_before_destroy","title":"on_before_destroy","text":"<pre><code>on_before_destroy() -&gt; None | Awaitable[None]\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def on_before_destroy(self) -&gt; None | Awaitable[None]: ...\n</code></pre>"},{"location":"api/#rxxxt.component.Component.on_before_update","title":"on_before_update","text":"<pre><code>on_before_update() -&gt; None | Awaitable[None]\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def on_before_update(self) -&gt; None | Awaitable[None]: ...\n</code></pre>"},{"location":"api/#rxxxt.component.Component.on_init","title":"on_init","text":"<pre><code>on_init() -&gt; None | Awaitable[None]\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def on_init(self) -&gt; None | Awaitable[None]: ...\n</code></pre>"},{"location":"api/#rxxxt.component.Component.render","title":"render  <code>abstractmethod</code>","text":"<pre><code>render() -&gt; Element | Awaitable[Element]\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>@abstractmethod\ndef render(self) -&gt; Element | Awaitable[Element]: ...\n</code></pre>"},{"location":"api/#rxxxt.component.Component.tonode","title":"tonode","text":"<pre><code>tonode(context: Context) -&gt; Node\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def tonode(self, context: Context) -&gt; 'Node': return ComponentNode(context, self)\n</code></pre>"},{"location":"api/#rxxxt.component.context_state","title":"context_state  <code>module-attribute</code>","text":"<pre><code>context_state = partial(_field_state, get_context_state_key)\n</code></pre>"},{"location":"api/#rxxxt.component.context_state_box","title":"context_state_box  <code>module-attribute</code>","text":"<pre><code>context_state_box = partial(_box_state, get_context_state_key)\n</code></pre>"},{"location":"api/#rxxxt.component.event_handler","title":"event_handler","text":"<pre><code>event_handler(**kwargs: Any)\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def event_handler(**kwargs: Any):\n  options = InputEventDescriptorOptions.model_validate(kwargs)\n  def _inner(fn: Callable[Concatenate[Any, FNP], FNR]) -&gt; UnboundEventHandler[FNP, FNR]: return UnboundEventHandler(fn, options)\n  return _inner\n</code></pre>"},{"location":"api/#rxxxt.component.global_state","title":"global_state  <code>module-attribute</code>","text":"<pre><code>global_state = partial(_field_state, get_global_state_key)\n</code></pre>"},{"location":"api/#rxxxt.component.global_state_box","title":"global_state_box  <code>module-attribute</code>","text":"<pre><code>global_state_box = partial(_box_state, get_global_state_key)\n</code></pre>"},{"location":"api/#rxxxt.component.HandleNavigate","title":"HandleNavigate","text":"<pre><code>HandleNavigate(location: str)\n</code></pre> <p>               Bases: <code>CustomAttribute</code></p> <p>Methods:</p> Name Description <code>tonode</code> <p>Attributes:</p> Name Type Description <code>location</code> Source code in <code>rxxxt/component.py</code> <pre><code>def __init__(self, location: str) -&gt; None:\n  super().__init__()\n  self.location = location\n</code></pre>"},{"location":"api/#rxxxt.component.HandleNavigate.location","title":"location  <code>instance-attribute</code>","text":"<pre><code>location = location\n</code></pre>"},{"location":"api/#rxxxt.component.HandleNavigate.tonode","title":"tonode","text":"<pre><code>tonode(context: Context, original_key: str) -&gt; Node\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def tonode(self, context: Context, original_key: str) -&gt; Node:\n  return TextNode(context, f\"{html.escape(original_key)}=\\\"window.rxxxt.navigate('{html.escape(self.location)}');\\\"\")\n</code></pre>"},{"location":"api/#rxxxt.component.local_state","title":"local_state  <code>module-attribute</code>","text":"<pre><code>local_state = partial(_field_state, get_local_state_key)\n</code></pre>"},{"location":"api/#rxxxt.component.local_state_box","title":"local_state_box  <code>module-attribute</code>","text":"<pre><code>local_state_box = partial(_box_state, get_local_state_key)\n</code></pre>"},{"location":"api/#rxxxt.component.SharedExternalState","title":"SharedExternalState","text":"<pre><code>SharedExternalState(initial_value: T)\n</code></pre> <p>               Bases: <code>Generic[T]</code></p> <p>Methods:</p> Name Description <code>__get__</code> <code>update</code> <p>Attributes:</p> Name Type Description <code>value</code> <code>T</code> Source code in <code>rxxxt/component.py</code> <pre><code>def __init__(self, initial_value: T) -&gt; None:\n  self._components: weakref.WeakSet[Component] = weakref.WeakSet()\n  self._value: T = initial_value\n</code></pre>"},{"location":"api/#rxxxt.component.SharedExternalState.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value: T\n</code></pre>"},{"location":"api/#rxxxt.component.SharedExternalState.__get__","title":"__get__","text":"<pre><code>__get__(obj: Any, objtype: Any = None)\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def __get__(self, obj: Any, objtype: Any=None):\n  if obj is None:\n    return self\n  if not isinstance(obj, Component):\n    raise TypeError(\"SharedExternalState must only be accessed from inside a component!\")\n  self._components.add(obj)\n  return self\n</code></pre>"},{"location":"api/#rxxxt.component.SharedExternalState.update","title":"update","text":"<pre><code>update()\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def update(self):\n  for component in self._components:\n    component.context.request_update()\n</code></pre>"},{"location":"api/#rxxxt.component.StateBox","title":"StateBox","text":"<pre><code>StateBox(key: str, state: State, default_factory: Callable[[], T], adapter: TypeAdapter[T])\n</code></pre> <p>               Bases: <code>Generic[T]</code>, <code>StateCell</code></p> <p>Methods:</p> Name Description <code>__enter__</code> <code>__exit__</code> <code>consume</code> <code>detach</code> <code>produce</code> <code>update</code> <p>Attributes:</p> Name Type Description <code>key</code> <code>value</code> Source code in <code>rxxxt/component.py</code> <pre><code>def __init__(self, key: str, state: State, default_factory: Callable[[], T], adapter: TypeAdapter[T]) -&gt; None:\n  super().__init__()\n  self._key = key\n  self._state = state\n  self._adapter = adapter\n  self._value: T\n\n  key_state = state.get(key)\n  key_state.add_consumer(self)\n  try: self._value = adapter.validate_json(key_state.get())\n  except ValueError:\n    self._value = default_factory()\n    key_state.set(self)\n</code></pre>"},{"location":"api/#rxxxt.component.StateBox.key","title":"key  <code>property</code>","text":"<pre><code>key\n</code></pre>"},{"location":"api/#rxxxt.component.StateBox.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value\n</code></pre>"},{"location":"api/#rxxxt.component.StateBox.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def __enter__(self): return self.value\n</code></pre>"},{"location":"api/#rxxxt.component.StateBox.__exit__","title":"__exit__","text":"<pre><code>__exit__(*_)\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def __exit__(self, *_): self.update()\n</code></pre>"},{"location":"api/#rxxxt.component.StateBox.consume","title":"consume","text":"<pre><code>consume(key: str, producer: Callable[[], str]) -&gt; Any\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def consume(self, key: str, producer: Callable[[], str]) -&gt; Any:\n  self._value = self._adapter.validate_json(producer())\n</code></pre>"},{"location":"api/#rxxxt.component.StateBox.detach","title":"detach","text":"<pre><code>detach(key: str) -&gt; Any\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def detach(self, key: str) -&gt; Any:\n  del self._value\n</code></pre>"},{"location":"api/#rxxxt.component.StateBox.produce","title":"produce","text":"<pre><code>produce(key: str) -&gt; str\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def produce(self, key: str) -&gt; str:\n  return self._adapter.dump_json(self._value).decode()\n</code></pre>"},{"location":"api/#rxxxt.component.StateBox.update","title":"update","text":"<pre><code>update()\n</code></pre> Source code in <code>rxxxt/component.py</code> <pre><code>def update(self):\n  self._state.get(self._key).set(self)\n</code></pre>"},{"location":"api/#rxxxt.elements.add_attributes","title":"add_attributes","text":"<pre><code>add_attributes(base: HTMLAttributes, **kwargs: HTMLAttributeValue)\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>def add_attributes(base: HTMLAttributes, **kwargs: HTMLAttributeValue):\n  return merge_attributes(kwargs, base)\n</code></pre>"},{"location":"api/#rxxxt.elements.class_map","title":"class_map","text":"<pre><code>class_map(map: dict[str, bool])\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>def class_map(map: dict[str, bool]):\n  return \" \".join([ k for k, v in map.items() if v ])\n</code></pre>"},{"location":"api/#rxxxt.elements.CustomAttribute","title":"CustomAttribute","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> Name Description <code>tonode</code>"},{"location":"api/#rxxxt.elements.CustomAttribute.tonode","title":"tonode  <code>abstractmethod</code>","text":"<pre><code>tonode(context: Context, original_key: str) -&gt; Node\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>@abstractmethod\ndef tonode(self, context: Context, original_key: str) -&gt; Node: ...\n</code></pre>"},{"location":"api/#rxxxt.elements.El","title":"El","text":""},{"location":"api/#rxxxt.elements.Element","title":"Element","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> Name Description <code>tonode</code>"},{"location":"api/#rxxxt.elements.Element.tonode","title":"tonode  <code>abstractmethod</code>","text":"<pre><code>tonode(context: Context) -&gt; Node\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>@abstractmethod\ndef tonode(self, context: Context) -&gt; Node: ...\n</code></pre>"},{"location":"api/#rxxxt.elements.ElementContent","title":"ElementContent  <code>module-attribute</code>","text":"<pre><code>ElementContent = Iterable[Element | str]\n</code></pre>"},{"location":"api/#rxxxt.elements.ElementFactory","title":"ElementFactory","text":"<p>               Bases: <code>Protocol</code></p> <p>Methods:</p> Name Description <code>__call__</code>"},{"location":"api/#rxxxt.elements.ElementFactory.__call__","title":"__call__","text":"<pre><code>__call__() -&gt; Element\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>def __call__(self) -&gt; Element: ...\n</code></pre>"},{"location":"api/#rxxxt.elements.HTMLAttributes","title":"HTMLAttributes  <code>module-attribute</code>","text":"<pre><code>HTMLAttributes = dict[str, HTMLAttributeValue]\n</code></pre>"},{"location":"api/#rxxxt.elements.HTMLAttributeValue","title":"HTMLAttributeValue  <code>module-attribute</code>","text":"<pre><code>HTMLAttributeValue = str | bool | int | float | CustomAttribute | Callable | None\n</code></pre>"},{"location":"api/#rxxxt.elements.HTMLElement","title":"HTMLElement","text":"<pre><code>HTMLElement(context: Context, tag: str, attributes: HTMLAttributes, content: ElementContent)\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>@fn_element\ndef HTMLElement(context: Context, tag: str, attributes: HTMLAttributes, content: ElementContent):\n  return ElementNode(context, tag, _html_attributes_to_nodes(context.sub(\"attributes\"), attributes), \\\n    _element_content_to_ordered_nodes(context.sub(\"children\"), content))\n</code></pre>"},{"location":"api/#rxxxt.elements.HTMLFragment","title":"HTMLFragment","text":"<pre><code>HTMLFragment(context: Context, content: ElementContent)\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>@fn_element\ndef HTMLFragment(context: Context, content: ElementContent):\n  return FragmentNode(context, _element_content_to_ordered_nodes(context, content))\n</code></pre>"},{"location":"api/#rxxxt.elements.HTMLVoidElement","title":"HTMLVoidElement","text":"<pre><code>HTMLVoidElement(context: Context, tag: str, attributes: HTMLAttributes)\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>@fn_element\ndef HTMLVoidElement(context: Context, tag: str, attributes: HTMLAttributes):\n  return VoidElementNode(context, tag, _html_attributes_to_nodes(context.sub(\"attributes\"), attributes))\n</code></pre>"},{"location":"api/#rxxxt.elements.KeyedElement","title":"KeyedElement","text":"<pre><code>KeyedElement(context: Context, key: str, element: Element)\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>@fn_element\ndef KeyedElement(context: Context, key: str, element: Element):\n  try: context = context.replace_index(key)\n  except ValueError as e: logging.debug(f\"Failed to replace index with key {key}\", e)\n  return element.tonode(context)\n</code></pre>"},{"location":"api/#rxxxt.elements.lazy_element","title":"lazy_element","text":"<pre><code>lazy_element(fn: Callable[Concatenate[Context, FNP], Element]) -&gt; Callable[FNP, Element]\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>def lazy_element(fn: Callable[Concatenate[Context, FNP], Element]) -&gt; Callable[FNP, 'Element']:\n  def _inner(context: Context, *args: FNP.args, **kwargs: FNP.kwargs) -&gt; Node:\n    return fn(context, *args, **kwargs).tonode(context)\n  return fn_element(_inner)\n</code></pre>"},{"location":"api/#rxxxt.elements.merge_attributes","title":"merge_attributes","text":"<pre><code>merge_attributes(a: HTMLAttributes, b: HTMLAttributes)\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>def merge_attributes(a: HTMLAttributes, b: HTMLAttributes):\n  return dict(_merge_attribute_items(itertools.chain(a.items(), b.items())))\n</code></pre>"},{"location":"api/#rxxxt.elements.query_selector_all_event","title":"query_selector_all_event","text":"<pre><code>query_selector_all_event(name: str, selector: str, handler: Callable)\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>def query_selector_all_event(name: str, selector: str, handler: Callable):\n  return El[\"rxxxt-query-selector-event\"](name=name, selector=selector, content=[], onemit=handler)\n</code></pre>"},{"location":"api/#rxxxt.elements.ScriptContent","title":"ScriptContent","text":"<pre><code>ScriptContent(context: Context, script: str)\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>@fn_element\ndef ScriptContent(context: Context, script: str):\n  return TextNode(context, script.replace(\"&lt;/\", \"&lt;\\\\/\"))\n</code></pre>"},{"location":"api/#rxxxt.elements.TextElement","title":"TextElement","text":"<pre><code>TextElement(context: Context, text: str)\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>@fn_element\ndef TextElement(context: Context, text: str):\n  return TextNode(context, html.escape(text))\n</code></pre>"},{"location":"api/#rxxxt.elements.UnescapedHTMLElement","title":"UnescapedHTMLElement","text":"<pre><code>UnescapedHTMLElement(context: Context, text: str)\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>@fn_element\ndef UnescapedHTMLElement(context: Context, text: str):\n  return TextNode(context, text)\n</code></pre>"},{"location":"api/#rxxxt.elements.VEl","title":"VEl","text":""},{"location":"api/#rxxxt.elements.window_event","title":"window_event","text":"<pre><code>window_event(name: str, handler: Callable)\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>def window_event(name: str, handler: Callable):\n  return El[\"rxxxt-window-event\"](name=name, content=[], onemit=handler)\n</code></pre>"},{"location":"api/#rxxxt.elements.WithRegistered","title":"WithRegistered","text":"<pre><code>WithRegistered(context: Context, register: dict[str, Any], child: Element)\n</code></pre> Source code in <code>rxxxt/elements.py</code> <pre><code>@fn_element\ndef WithRegistered(context: Context, register: dict[str, Any], child: Element):\n  return child.tonode(context.update_registry(register))\n</code></pre>"},{"location":"api/#rxxxt.execution.Context","title":"Context  <code>dataclass</code>","text":"<pre><code>Context(id: ContextStack, state: State, registry: dict[str, Any], config: ContextConfig, execution: Execution)\n</code></pre> <p>Classes:</p> Name Description <code>StateConsumer</code> <p>Methods:</p> Name Description <code>__hash__</code> <code>delete_cookie</code> <code>emit</code> <code>get_header</code> <code>match_path</code> <code>navigate</code> <code>registered</code> <code>replace_index</code> <code>request_update</code> <code>set_cookie</code> <code>sub</code> <code>subscribe</code> <code>update_registry</code> <code>use_websocket</code> <p>Attributes:</p> Name Type Description <code>config</code> <code>ContextConfig</code> <code>cookies</code> <code>dict[str, str]</code> <code>execution</code> <code>Execution</code> <code>id</code> <code>ContextStack</code> <code>location</code> <code>path</code> <code>query_string</code> <code>registry</code> <code>dict[str, Any]</code> <code>sid</code> <code>stack_sids</code> <code>state</code> <code>State</code> <code>update_consumer</code>"},{"location":"api/#rxxxt.execution.Context.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config: ContextConfig\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.cookies","title":"cookies  <code>property</code>","text":"<pre><code>cookies: dict[str, str]\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.execution","title":"execution  <code>instance-attribute</code>","text":"<pre><code>execution: Execution\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: ContextStack\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.location","title":"location  <code>property</code>","text":"<pre><code>location\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.path","title":"path  <code>property</code>","text":"<pre><code>path\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.query_string","title":"query_string  <code>property</code>","text":"<pre><code>query_string\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.registry","title":"registry  <code>instance-attribute</code>","text":"<pre><code>registry: dict[str, Any]\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.sid","title":"sid  <code>cached</code> <code>property</code>","text":"<pre><code>sid\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.stack_sids","title":"stack_sids  <code>property</code>","text":"<pre><code>stack_sids\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: State\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.update_consumer","title":"update_consumer  <code>cached</code> <code>property</code>","text":"<pre><code>update_consumer\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.StateConsumer","title":"StateConsumer","text":"<pre><code>StateConsumer(context: Context)\n</code></pre> <p>               Bases: <code>StateConsumer</code></p> <p>Methods:</p> Name Description <code>consume</code> <code>detach</code> <p>Attributes:</p> Name Type Description <code>context</code> Source code in <code>rxxxt/execution.py</code> <pre><code>def __init__(self, context: 'Context') -&gt; None: self.context = context\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.StateConsumer.context","title":"context  <code>instance-attribute</code>","text":"<pre><code>context = context\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.StateConsumer.consume","title":"consume","text":"<pre><code>consume(key: str, producer: Callable[[], str]) -&gt; Any\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def consume(self, key: str, producer: Callable[[], str]) -&gt; Any: self.context.request_update()\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.StateConsumer.detach","title":"detach","text":"<pre><code>detach(key: str) -&gt; Any\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def detach(self, key: str) -&gt; Any: self.context.request_update()\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def __hash__(self) -&gt; int:\n  return hash(self.id)\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.delete_cookie","title":"delete_cookie","text":"<pre><code>delete_cookie(name: str, mirror_state: bool = True)\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def delete_cookie(self, name: str, mirror_state: bool = True):\n  self.set_cookie(name=name, max_age=-1, mirror_state=False)\n  if mirror_state:\n    self.state.set_many({ \"!header;cookie\": \"; \".join(f\"{k}={v}\" for k, v in self.cookies.items() if k != name) })\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.emit","title":"emit","text":"<pre><code>emit(name: str, data: dict[str, int | float | str | bool | None])\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def emit(self, name: str, data: dict[str, int | float | str | bool | None]):\n  self.execution.add_output_event(dict(event=\"custom\", name=name, data=data))\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.get_header","title":"get_header","text":"<pre><code>get_header(name: str) -&gt; tuple[str, ...]\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def get_header(self, name: str) -&gt; tuple[str, ...]:\n  header_lines = self._get_state_str_subscribe(f\"!header;{name}\")\n  if header_lines is None: return ()\n  else: return tuple(header_lines.splitlines())\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.match_path","title":"match_path","text":"<pre><code>match_path(pattern: str, re_flags: int = IGNORECASE)\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def match_path(self, pattern: str, re_flags: int = re.IGNORECASE):\n  return match_path(pattern, self.path, re_flags)\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.navigate","title":"navigate","text":"<pre><code>navigate(location: str)\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def navigate(self, location: str):\n  is_full_url = \":\" in location # colon means full url\n  if not is_full_url: self.state.get(\"!location\").set(location)\n  self.execution.add_output_event(dict(event=\"navigate\", location=location, requires_refresh=is_full_url or None))\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.registered","title":"registered","text":"<pre><code>registered(name: str, t: type[T]) -&gt; T\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def registered(self, name: str, t: type[T]) -&gt; T:\n  if not isinstance((val:=self.registry.get(name)), t):\n    raise TypeError(f\"Invalid type in get_registered '{type(val)}'!\")\n  return val\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.replace_index","title":"replace_index","text":"<pre><code>replace_index(key: str)\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def replace_index(self, key: str):\n  if isinstance(self.id[-1], int): return dataclasses.replace(self, id=self.id[:-1] + (key,))\n  raise ValueError(\"No index to replace!\")\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.request_update","title":"request_update","text":"<pre><code>request_update()\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def request_update(self): self.execution.request_update(self.id)\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.set_cookie","title":"set_cookie","text":"<pre><code>set_cookie(name: str, value: str | None = None, expires: datetime | None = None, path: str | None = None, secure: bool | None = None, http_only: bool | None = None, domain: str | None = None, max_age: int | None = None, mirror_state: bool = True)\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def set_cookie(self, name: str, value: str | None = None, expires: datetime | None = None, path: str | None = None,\n              secure: bool | None = None, http_only: bool | None = None, domain: str | None = None, max_age: int | None = None, mirror_state: bool = True):\n  if not re.match(r'^[^=;, \\t\\n\\r\\f\\v]+$', name): raise ValueError(\"Invalid cookie name\")\n  if value is not None and not re.match(r'^[^;, \\t\\n\\r\\f\\v]+$', value): raise ValueError(\"Invalid value.\")\n  if domain is not None and not re.match(r'^[^;, \\t\\n\\r\\f\\v]+$', domain): raise ValueError(\"Invalid domain.\")\n  if path is not None and not re.match(r'^[^\\x00-\\x20;,\\s]+$', path): raise ValueError(\"Invalid path.\")\n\n  expires_str = None if expires is None else expires.isoformat()\n\n  self.execution.add_output_event(dict(event=\"set-cookie\", name=name, value=value, expires=expires_str, path=path, secure=secure, http_only=http_only, domain=domain, max_age=max_age))\n  if mirror_state:\n    self.state.set_many({ \"!header;cookie\": \"; \".join(f\"{k}={v}\" for k, v in (self.cookies | { name: value }).items()) })\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.sub","title":"sub","text":"<pre><code>sub(key: ContextStackKey)\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def sub(self, key: ContextStackKey): return dataclasses.replace(self, id=self.id + (key,))\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.subscribe","title":"subscribe","text":"<pre><code>subscribe(key: str)\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def subscribe(self, key: str): self.state.get(key).add_consumer(self.update_consumer)\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.update_registry","title":"update_registry","text":"<pre><code>update_registry(registry: dict[str, Any])\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def update_registry(self, registry: dict[str, Any]): return dataclasses.replace(self, registry=self.registry | registry)\n</code></pre>"},{"location":"api/#rxxxt.execution.Context.use_websocket","title":"use_websocket","text":"<pre><code>use_websocket(websocket: bool = True)\n</code></pre> Source code in <code>rxxxt/execution.py</code> <pre><code>def use_websocket(self, websocket: bool = True): self.execution.add_output_event(dict(event=\"use-websocket\", websocket=websocket))\n</code></pre>"},{"location":"api/#rxxxt.execution.InputEventDescriptorOptions","title":"InputEventDescriptorOptions","text":"<p>               Bases: <code>BaseModel</code></p> <p>Attributes:</p> Name Type Description <code>debounce</code> <code>int | None</code> <code>default_params</code> <code>dict[str, int | float | str | bool | None] | None</code> <code>no_trigger</code> <code>bool</code> <code>param_map</code> <code>dict[str, str]</code> <code>prevent_default</code> <code>bool</code> <code>throttle</code> <code>int | None</code>"},{"location":"api/#rxxxt.execution.InputEventDescriptorOptions.debounce","title":"debounce  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debounce: int | None = None\n</code></pre>"},{"location":"api/#rxxxt.execution.InputEventDescriptorOptions.default_params","title":"default_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>default_params: dict[str, int | float | str | bool | None] | None = None\n</code></pre>"},{"location":"api/#rxxxt.execution.InputEventDescriptorOptions.no_trigger","title":"no_trigger  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>no_trigger: bool = False\n</code></pre>"},{"location":"api/#rxxxt.execution.InputEventDescriptorOptions.param_map","title":"param_map  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>param_map: dict[str, str] = field(default_factory=dict)\n</code></pre>"},{"location":"api/#rxxxt.execution.InputEventDescriptorOptions.prevent_default","title":"prevent_default  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prevent_default: bool = False\n</code></pre>"},{"location":"api/#rxxxt.execution.InputEventDescriptorOptions.throttle","title":"throttle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>throttle: int | None = None\n</code></pre>"},{"location":"api/#rxxxt.execution.State","title":"State","text":"<pre><code>State()\n</code></pre> <p>Methods:</p> Name Description <code>cleanup</code> <code>delete</code> <code>destroy</code> <code>get</code> <code>get_key_values</code> <code>set_many</code> <p>Attributes:</p> Name Type Description <code>keys</code> Source code in <code>rxxxt/state.py</code> <pre><code>def __init__(self) -&gt; None:\n  self._key_states: dict[str, KeyState] = {}\n</code></pre>"},{"location":"api/#rxxxt.execution.State.keys","title":"keys  <code>property</code>","text":"<pre><code>keys\n</code></pre>"},{"location":"api/#rxxxt.execution.State.cleanup","title":"cleanup","text":"<pre><code>cleanup(inactive_prefixes: Set[str])\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def cleanup(self, inactive_prefixes: Set[str]):\n  active_keys = self._get_active_keys(inactive_prefixes)\n  inactive_keys = tuple(key for key in self._key_states.keys() if key not in active_keys)\n  for key in inactive_keys:\n    return self.delete(key)\n</code></pre>"},{"location":"api/#rxxxt.execution.State.delete","title":"delete","text":"<pre><code>delete(key: str)\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def delete(self, key: str):\n  state = self._key_states.pop(key, None)\n  if state is not None:\n    state.destroy()\n</code></pre>"},{"location":"api/#rxxxt.execution.State.destroy","title":"destroy","text":"<pre><code>destroy()\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def destroy(self):\n  for state in self._key_states.values():\n    state.destroy()\n  self._key_states.clear()\n</code></pre>"},{"location":"api/#rxxxt.execution.State.get","title":"get","text":"<pre><code>get(key: str)\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def get(self, key: str):\n  if (state := self._key_states.get(key)) is None:\n    state = KeyState(key, None)\n    self._key_states[key] = state\n  return state\n</code></pre>"},{"location":"api/#rxxxt.execution.State.get_key_values","title":"get_key_values","text":"<pre><code>get_key_values(inactive_prefixes: Set[str])\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def get_key_values(self, inactive_prefixes: Set[str]):\n  active_keys = self._get_active_keys(inactive_prefixes)\n  return { key: state.get() for key, state in self._key_states.items() if key in active_keys and state.has_value }\n</code></pre>"},{"location":"api/#rxxxt.execution.State.set_many","title":"set_many","text":"<pre><code>set_many(kvs: dict[str, str])\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def set_many(self, kvs: dict[str, str]):\n  for k, v in kvs.items(): self.get(k).set(v)\n</code></pre>"},{"location":"api/#rxxxt.helpers.JWTError","title":"JWTError","text":"<p>               Bases: <code>Exception</code></p>"},{"location":"api/#rxxxt.helpers.JWTManager","title":"JWTManager","text":"<pre><code>JWTManager(secret: bytes, max_age: timedelta, algorithm: str = 'HS512')\n</code></pre> <p>Classes:</p> Name Description <code>JWTHeader</code> <code>JWTPayloadValidations</code> <p>Methods:</p> Name Description <code>b64_url_decode</code> <code>b64_url_encode</code> <code>encode_json</code> <code>sign</code> <code>verify</code> <p>Attributes:</p> Name Type Description <code>JWTPayloadAdapter</code> Source code in <code>rxxxt/helpers.py</code> <pre><code>def __init__(self, secret: bytes, max_age: timedelta, algorithm: str = \"HS512\") -&gt; None:\n  super().__init__()\n  self._secret = secret\n  self._max_age: timedelta = max_age\n  self._algorithm = algorithm\n  self._digest = { \"HS256\": hashlib.sha256, \"HS384\": hashlib.sha384, \"HS512\": hashlib.sha512 }[algorithm]\n  self._jwt_header = JWTManager.encode_json({ \"typ\": \"JWT\", \"alg\": self._algorithm }) + b\".\"\n</code></pre>"},{"location":"api/#rxxxt.helpers.JWTManager.JWTPayloadAdapter","title":"JWTPayloadAdapter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>JWTPayloadAdapter = TypeAdapter(dict[str, Any])\n</code></pre>"},{"location":"api/#rxxxt.helpers.JWTManager.JWTHeader","title":"JWTHeader","text":"<p>               Bases: <code>BaseModel</code></p> <p>Attributes:</p> Name Type Description <code>alg</code> <code>str</code> <code>typ</code> <code>Literal['JWT']</code>"},{"location":"api/#rxxxt.helpers.JWTManager.JWTHeader.alg","title":"alg  <code>instance-attribute</code>","text":"<pre><code>alg: str\n</code></pre>"},{"location":"api/#rxxxt.helpers.JWTManager.JWTHeader.typ","title":"typ  <code>instance-attribute</code>","text":"<pre><code>typ: Literal['JWT']\n</code></pre>"},{"location":"api/#rxxxt.helpers.JWTManager.JWTPayloadValidations","title":"JWTPayloadValidations","text":"<p>               Bases: <code>BaseModel</code></p> <p>Methods:</p> Name Description <code>is_valid</code> <p>Attributes:</p> Name Type Description <code>exp</code> <code>int</code>"},{"location":"api/#rxxxt.helpers.JWTManager.JWTPayloadValidations.exp","title":"exp  <code>instance-attribute</code>","text":"<pre><code>exp: int\n</code></pre>"},{"location":"api/#rxxxt.helpers.JWTManager.JWTPayloadValidations.is_valid","title":"is_valid","text":"<pre><code>is_valid()\n</code></pre> Source code in <code>rxxxt/helpers.py</code> <pre><code>def is_valid(self):\n  expires_dt = datetime.fromtimestamp(self.exp, timezone.utc)\n  return expires_dt &gt;= datetime.now(tz=timezone.utc)\n</code></pre>"},{"location":"api/#rxxxt.helpers.JWTManager.b64_url_decode","title":"b64_url_decode  <code>staticmethod</code>","text":"<pre><code>b64_url_decode(value: bytes | bytearray)\n</code></pre> Source code in <code>rxxxt/helpers.py</code> <pre><code>@staticmethod\ndef b64_url_decode(value: bytes | bytearray):\n  return base64.urlsafe_b64decode(value + b\"=\" * (4 - len(value) % 4))\n</code></pre>"},{"location":"api/#rxxxt.helpers.JWTManager.b64_url_encode","title":"b64_url_encode  <code>staticmethod</code>","text":"<pre><code>b64_url_encode(value: bytes | bytearray)\n</code></pre> Source code in <code>rxxxt/helpers.py</code> <pre><code>@staticmethod\ndef b64_url_encode(value: bytes | bytearray):\n  return base64.urlsafe_b64encode(value).rstrip(b\"=\")\n</code></pre>"},{"location":"api/#rxxxt.helpers.JWTManager.encode_json","title":"encode_json  <code>staticmethod</code>","text":"<pre><code>encode_json(obj: Any)\n</code></pre> Source code in <code>rxxxt/helpers.py</code> <pre><code>@staticmethod\ndef encode_json(obj: Any):\n  return JWTManager.b64_url_encode(json.dumps(obj).encode())\n</code></pre>"},{"location":"api/#rxxxt.helpers.JWTManager.sign","title":"sign","text":"<pre><code>sign(extra_fields: dict[str, Any])\n</code></pre> Source code in <code>rxxxt/helpers.py</code> <pre><code>def sign(self, extra_fields: dict[str, Any]):\n  try:\n    expires_at = int((datetime.now(tz=timezone.utc) + self._max_age).timestamp())\n    stream = io.BytesIO()\n    _ = stream.write(self._jwt_header)\n    _ = stream.write(JWTManager.encode_json({ \"exp\": expires_at, **extra_fields }))\n    signature = hmac.digest(self._secret, stream.getvalue(), self._digest)\n    _ = stream.write(b\".\")\n    _ = stream.write(JWTManager.b64_url_encode(signature))\n    return stream.getvalue().decode()\n  except Exception as e:\n    if not isinstance(e, JWTError): raise JWTError(e)\n    else: raise e\n</code></pre>"},{"location":"api/#rxxxt.helpers.JWTManager.verify","title":"verify","text":"<pre><code>verify(token: str)\n</code></pre> Source code in <code>rxxxt/helpers.py</code> <pre><code>def verify(self, token: str):\n  try:\n    parts = token.encode().split(b\".\")\n    if len(parts) != 3: raise JWTError(\"invalid format (expected 3 parts)\")\n\n    header = JWTManager.JWTHeader.model_validate_json(JWTManager.b64_url_decode(parts[0]))\n    if header.alg != self._algorithm: raise JWTError(\"invalid algorithm in header\")\n\n    ref_signature = hmac.digest(self._secret, parts[0] + b\".\" + parts[1], self._digest)\n    if not hmac.compare_digest(JWTManager.b64_url_decode(parts[2]), ref_signature):\n      raise JWTError(\"invalid JWT signature!\")\n\n    full_payload = JWTManager.JWTPayloadAdapter.validate_json(JWTManager.b64_url_decode(parts[1]))\n    if not JWTManager.JWTPayloadValidations.model_validate(full_payload).is_valid():\n      raise JWTError(\"token expired\")\n\n    full_payload.pop(\"exp\", None)\n    return full_payload\n  except Exception as e:\n    if not isinstance(e, JWTError): raise JWTError(e)\n    else: raise e\n</code></pre>"},{"location":"api/#rxxxt.helpers.match_path","title":"match_path","text":"<pre><code>match_path(pattern: str, path: str, re_flags: int = IGNORECASE)\n</code></pre> Source code in <code>rxxxt/helpers.py</code> <pre><code>def match_path(pattern: str, path: str, re_flags: int = re.IGNORECASE):\n  return _compile_matcher(pattern, re_flags)(path)\n</code></pre>"},{"location":"api/#rxxxt.page.default_page","title":"default_page","text":"<pre><code>default_page(header: Element, content: Element, body_end: Element)\n</code></pre> Source code in <code>rxxxt/page.py</code> <pre><code>def default_page(header: Element, content: Element, body_end: Element):\n  return HTMLFragment([\n    VEl[\"!DOCTYPE\"](html=None),\n    El.html(content=[\n      El.head(content=[\n        VEl.meta(charset=\"UTF-8\"),\n        VEl.meta(name=\"viewport\", content=\"width=device-width, initial-scale=1.0\"),\n        header\n      ]),\n      El.body(content=[\n        content,\n        body_end\n      ])\n    ])\n  ])\n</code></pre>"},{"location":"api/#rxxxt.page.PageBuilder","title":"PageBuilder","text":"<pre><code>PageBuilder(page_factory: PageFactory = default_page)\n</code></pre> <p>               Bases: <code>PageFactory</code></p> <p>Methods:</p> Name Description <code>__call__</code> <code>add_body_end</code> <code>add_body_script</code> <code>add_header</code> <code>add_header_script</code> <code>add_stylesheet</code> Source code in <code>rxxxt/page.py</code> <pre><code>def __init__(self, page_factory: PageFactory = default_page) -&gt; None:\n  self._header_elements: list[Element] = []\n  self._body_end_elements: list[Element] = []\n  self._page_factory = page_factory\n</code></pre>"},{"location":"api/#rxxxt.page.PageBuilder.__call__","title":"__call__","text":"<pre><code>__call__(header: Element, content: Element, body_end: Element) -&gt; Element\n</code></pre> Source code in <code>rxxxt/page.py</code> <pre><code>def __call__(self, header: Element, content: Element, body_end: Element) -&gt; Element:\n  return self._page_factory(HTMLFragment([ header, *self._header_elements ]), content, HTMLFragment([ body_end, *self._body_end_elements ]))\n</code></pre>"},{"location":"api/#rxxxt.page.PageBuilder.add_body_end","title":"add_body_end","text":"<pre><code>add_body_end(el: Element)\n</code></pre> Source code in <code>rxxxt/page.py</code> <pre><code>def add_body_end(self, el: Element): self._body_end_elements.append(el)\n</code></pre>"},{"location":"api/#rxxxt.page.PageBuilder.add_body_script","title":"add_body_script","text":"<pre><code>add_body_script(url: str, content: ElementContent = (), **kwargs: HTMLAttributeValue)\n</code></pre> Source code in <code>rxxxt/page.py</code> <pre><code>def add_body_script(self, url: str, content: ElementContent = (), **kwargs: HTMLAttributeValue):\n  self.add_body_end(El.script(src=url, content=content, **kwargs))\n</code></pre>"},{"location":"api/#rxxxt.page.PageBuilder.add_header","title":"add_header","text":"<pre><code>add_header(el: Element)\n</code></pre> Source code in <code>rxxxt/page.py</code> <pre><code>def add_header(self, el: Element): self._header_elements.append(el)\n</code></pre>"},{"location":"api/#rxxxt.page.PageBuilder.add_header_script","title":"add_header_script","text":"<pre><code>add_header_script(url: str, content: ElementContent = (), **kwargs: HTMLAttributeValue)\n</code></pre> Source code in <code>rxxxt/page.py</code> <pre><code>def add_header_script(self, url: str, content: ElementContent = (), **kwargs: HTMLAttributeValue):\n  self.add_header(El.script(src=url, content=content, **kwargs))\n</code></pre>"},{"location":"api/#rxxxt.page.PageBuilder.add_stylesheet","title":"add_stylesheet","text":"<pre><code>add_stylesheet(url: str, **kwargs: HTMLAttributeValue)\n</code></pre> Source code in <code>rxxxt/page.py</code> <pre><code>def add_stylesheet(self, url: str, **kwargs: HTMLAttributeValue): self.add_header(VEl.link(rel=\"stylesheet\", href=url, **kwargs))\n</code></pre>"},{"location":"api/#rxxxt.page.PageFactory","title":"PageFactory","text":"<p>               Bases: <code>Protocol</code></p> <p>Methods:</p> Name Description <code>__call__</code>"},{"location":"api/#rxxxt.page.PageFactory.__call__","title":"__call__","text":"<pre><code>__call__(header: Element, content: Element, body_end: Element) -&gt; Element\n</code></pre> Source code in <code>rxxxt/page.py</code> <pre><code>def __call__(self, header: Element, content: Element, body_end: Element) -&gt; Element: ...\n</code></pre>"},{"location":"api/#rxxxt.router.Router","title":"Router","text":"<pre><code>Router()\n</code></pre> <p>               Bases: <code>ElementFactory</code></p> <p>Classes:</p> Name Description <code>RoutedComponent</code> <p>Methods:</p> Name Description <code>__call__</code> <code>add_route</code> <code>add_router</code> <code>route</code> Source code in <code>rxxxt/router.py</code> <pre><code>def __init__(self) -&gt; None:\n  self._routes: list[tuple[str, ElementFactory]] = []\n</code></pre>"},{"location":"api/#rxxxt.router.Router.RoutedComponent","title":"RoutedComponent","text":"<pre><code>RoutedComponent(routes: tuple[tuple[str, ElementFactory], ...])\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Methods:</p> Name Description <code>on_before_update</code> <code>render</code> <p>Attributes:</p> Name Type Description <code>params</code> Source code in <code>rxxxt/router.py</code> <pre><code>def __init__(self, routes: tuple[tuple[str, ElementFactory], ...]):\n  super().__init__()\n  self._routes = routes\n  self._selected_match: tuple[int, ElementFactory, dict[str, str]] | None = None\n</code></pre>"},{"location":"api/#rxxxt.router.Router.RoutedComponent.params","title":"params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>params = router_params()\n</code></pre>"},{"location":"api/#rxxxt.router.Router.RoutedComponent.on_before_update","title":"on_before_update  <code>async</code>","text":"<pre><code>on_before_update() -&gt; None\n</code></pre> Source code in <code>rxxxt/router.py</code> <pre><code>async def on_before_update(self) -&gt; None:\n  self._selected_match = self._get_current_match()\n  self.params = typing.cast(dict[str, str], dict()) if self._selected_match is None else self._selected_match[2]\n</code></pre>"},{"location":"api/#rxxxt.router.Router.RoutedComponent.render","title":"render","text":"<pre><code>render() -&gt; Element\n</code></pre> Source code in <code>rxxxt/router.py</code> <pre><code>def render(self) -&gt; Element:\n  if self._selected_match is None:\n    return El.h1(content=[\"Not found!\"])\n  else:\n    return TaggedElement(str(self._selected_match[0]), self._selected_match[1]())\n</code></pre>"},{"location":"api/#rxxxt.router.Router.__call__","title":"__call__","text":"<pre><code>__call__() -&gt; Element\n</code></pre> Source code in <code>rxxxt/router.py</code> <pre><code>def __call__(self) -&gt; Element: return Router.RoutedComponent(tuple(self._routes))\n</code></pre>"},{"location":"api/#rxxxt.router.Router.add_route","title":"add_route","text":"<pre><code>add_route(pattern: str, element_factory: ElementFactory)\n</code></pre> Source code in <code>rxxxt/router.py</code> <pre><code>def add_route(self, pattern: str, element_factory: ElementFactory): self._routes.append((pattern, element_factory))\n</code></pre>"},{"location":"api/#rxxxt.router.Router.add_router","title":"add_router","text":"<pre><code>add_router(router: Router)\n</code></pre> Source code in <code>rxxxt/router.py</code> <pre><code>def add_router(self, router: 'Router'): self._routes.extend(router._routes)\n</code></pre>"},{"location":"api/#rxxxt.router.Router.route","title":"route","text":"<pre><code>route(pattern: str)\n</code></pre> Source code in <code>rxxxt/router.py</code> <pre><code>def route(self, pattern: str):\n  def _inner(fn: ElementFactory):\n    self.add_route(pattern, fn)\n    return fn\n  return _inner\n</code></pre>"},{"location":"api/#rxxxt.router.router_params","title":"router_params","text":"<pre><code>router_params()\n</code></pre> Source code in <code>rxxxt/router.py</code> <pre><code>def router_params(): return context_state(dict[str, str], name=\"*rp*\")\n</code></pre>"},{"location":"api/#rxxxt.session.AppConfig","title":"AppConfig  <code>dataclass</code>","text":"<pre><code>AppConfig(enable_web_socket_state_updates: bool | None = None, disable_http_update_retry: bool | None = None)\n</code></pre> <p>Attributes:</p> Name Type Description <code>disable_http_update_retry</code> <code>bool | None</code> <code>enable_web_socket_state_updates</code> <code>bool | None</code>"},{"location":"api/#rxxxt.session.AppConfig.disable_http_update_retry","title":"disable_http_update_retry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>disable_http_update_retry: bool | None = None\n</code></pre>"},{"location":"api/#rxxxt.session.AppConfig.enable_web_socket_state_updates","title":"enable_web_socket_state_updates  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>enable_web_socket_state_updates: bool | None = None\n</code></pre>"},{"location":"api/#rxxxt.state.default_state_resolver","title":"default_state_resolver","text":"<pre><code>default_state_resolver() -&gt; JWTStateResolver\n</code></pre> <p>Creates a JWTStateResolver. Uses the environment variable <code>JWT_SECRET</code> as its secret, if set, otherwise creates a new random, temporary secret.</p> Source code in <code>rxxxt/state.py</code> <pre><code>def default_state_resolver() -&gt; JWTStateResolver:\n  \"\"\"\n  Creates a JWTStateResolver.\n  Uses the environment variable `JWT_SECRET` as its secret, if set, otherwise creates a new random, temporary secret.\n  \"\"\"\n\n  jwt_secret = os.getenv(\"JWT_SECRET\", None)\n  if jwt_secret is None: jwt_secret = secrets.token_bytes(64)\n  else: jwt_secret = jwt_secret.encode(\"utf-8\")\n  return JWTStateResolver(jwt_secret)\n</code></pre>"},{"location":"api/#rxxxt.state.JWTStateResolver","title":"JWTStateResolver","text":"<pre><code>JWTStateResolver(secret: bytes, max_age: timedelta | None = None, algorithm: str = 'HS512')\n</code></pre> <p>               Bases: <code>StateResolver</code></p> <p>Methods:</p> Name Description <code>create_token</code> <code>resolve</code> <p>Attributes:</p> Name Type Description <code>StateDataAdapter</code> Source code in <code>rxxxt/state.py</code> <pre><code>def __init__(self, secret: bytes, max_age: timedelta | None = None, algorithm: str = \"HS512\") -&gt; None:\n  super().__init__()\n  self._jwt_manager = JWTManager(secret, timedelta(days=1) if max_age is None else max_age, algorithm)\n</code></pre>"},{"location":"api/#rxxxt.state.JWTStateResolver.StateDataAdapter","title":"StateDataAdapter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StateDataAdapter = TypeAdapter(dict[str, str])\n</code></pre>"},{"location":"api/#rxxxt.state.JWTStateResolver.create_token","title":"create_token","text":"<pre><code>create_token(data: dict[str, str], old_token: str | None) -&gt; str\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def create_token(self, data: dict[str, str], old_token: str | None) -&gt; str:\n  try: return self._jwt_manager.sign({ \"d\": data })\n  except JWTError as e: raise StateResolverError(e)\n</code></pre>"},{"location":"api/#rxxxt.state.JWTStateResolver.resolve","title":"resolve","text":"<pre><code>resolve(token: str) -&gt; dict[str, str]\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def resolve(self, token: str) -&gt; dict[str, str]:\n  try:\n    payload = self._jwt_manager.verify(token)\n    return JWTStateResolver.StateDataAdapter.validate_python(payload[\"d\"])\n  except (ValidationError, JWTError) as e: raise StateResolverError(e)\n</code></pre>"},{"location":"api/#rxxxt.state.State","title":"State","text":"<pre><code>State()\n</code></pre> <p>Methods:</p> Name Description <code>cleanup</code> <code>delete</code> <code>destroy</code> <code>get</code> <code>get_key_values</code> <code>set_many</code> <p>Attributes:</p> Name Type Description <code>keys</code> Source code in <code>rxxxt/state.py</code> <pre><code>def __init__(self) -&gt; None:\n  self._key_states: dict[str, KeyState] = {}\n</code></pre>"},{"location":"api/#rxxxt.state.State.keys","title":"keys  <code>property</code>","text":"<pre><code>keys\n</code></pre>"},{"location":"api/#rxxxt.state.State.cleanup","title":"cleanup","text":"<pre><code>cleanup(inactive_prefixes: Set[str])\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def cleanup(self, inactive_prefixes: Set[str]):\n  active_keys = self._get_active_keys(inactive_prefixes)\n  inactive_keys = tuple(key for key in self._key_states.keys() if key not in active_keys)\n  for key in inactive_keys:\n    return self.delete(key)\n</code></pre>"},{"location":"api/#rxxxt.state.State.delete","title":"delete","text":"<pre><code>delete(key: str)\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def delete(self, key: str):\n  state = self._key_states.pop(key, None)\n  if state is not None:\n    state.destroy()\n</code></pre>"},{"location":"api/#rxxxt.state.State.destroy","title":"destroy","text":"<pre><code>destroy()\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def destroy(self):\n  for state in self._key_states.values():\n    state.destroy()\n  self._key_states.clear()\n</code></pre>"},{"location":"api/#rxxxt.state.State.get","title":"get","text":"<pre><code>get(key: str)\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def get(self, key: str):\n  if (state := self._key_states.get(key)) is None:\n    state = KeyState(key, None)\n    self._key_states[key] = state\n  return state\n</code></pre>"},{"location":"api/#rxxxt.state.State.get_key_values","title":"get_key_values","text":"<pre><code>get_key_values(inactive_prefixes: Set[str])\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def get_key_values(self, inactive_prefixes: Set[str]):\n  active_keys = self._get_active_keys(inactive_prefixes)\n  return { key: state.get() for key, state in self._key_states.items() if key in active_keys and state.has_value }\n</code></pre>"},{"location":"api/#rxxxt.state.State.set_many","title":"set_many","text":"<pre><code>set_many(kvs: dict[str, str])\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>def set_many(self, kvs: dict[str, str]):\n  for k, v in kvs.items(): self.get(k).set(v)\n</code></pre>"},{"location":"api/#rxxxt.state.StateResolver","title":"StateResolver","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> Name Description <code>create_token</code> <code>resolve</code>"},{"location":"api/#rxxxt.state.StateResolver.create_token","title":"create_token  <code>abstractmethod</code>","text":"<pre><code>create_token(data: dict[str, str], old_token: str | None) -&gt; str | Awaitable[str]\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>@abstractmethod\ndef create_token(self, data: dict[str, str], old_token: str | None) -&gt; str | Awaitable[str]: pass\n</code></pre>"},{"location":"api/#rxxxt.state.StateResolver.resolve","title":"resolve  <code>abstractmethod</code>","text":"<pre><code>resolve(token: str) -&gt; dict[str, str] | Awaitable[dict[str, str]]\n</code></pre> Source code in <code>rxxxt/state.py</code> <pre><code>@abstractmethod\ndef resolve(self, token: str) -&gt; dict[str, str] | Awaitable[dict[str, str]]: pass\n</code></pre>"},{"location":"app/","title":"<code>App</code>","text":"<p>A rxxxt app is an ASGI application. It can be used, run and served like any other ASGI application.</p> <p>Apps can be created by simply passing an element factory (a function producing an element) to <code>App</code>.</p> <p>Let's write a \"Hello World!\" app: <pre><code>from rxxxt import App, El\nimport uvicorn\n\ndef element_factory():\n  return El.div(content=[\"Hello World!\"])\n\napp = App(element_factory)\nuvicorn.run(app)\n</code></pre></p> <p>Anything that returns an element, if called can be used as an <code>element_factory</code>. Like this \"Hello World\" component:</p> <pre><code>from rxxxt import App, El, Component\nimport uvicorn\n\nclass HelloWorld(Component):\n  def render(self) -&gt; Element:\n    return El.div(content=[\"Hello World\"])\n\napp = App(HelloWorld)\nuvicorn.run(app)\n</code></pre> <p>In addition to the element factory, a <code>state_resolver</code> (see State), <code>page_factory</code>, and <code>config</code> (an <code>AppConfig</code>) can be passed to <code>App</code>.</p>"},{"location":"app/#appconfig","title":"AppConfig","text":"<ul> <li><code>enable_web_socket_state_updates</code>: set to <code>True</code> when websocket pushes should include a refreshed state token so the client can keep its <code>StateResolver</code> data after the socket closes or falls back to HTTP. Leave it <code>False</code> when the websocket never needs to persist state beyond its lifetime.</li> <li><code>disable_http_update_retry</code>: set to <code>True</code> to disable resending events over HTTP when the response indicates the update is stale (new events arrived while the request was processing).</li> </ul>"},{"location":"app/#pagefactory","title":"PageFactory","text":"<p>A PageFactory is a function receiving</p> <ul> <li>a header element,</li> <li>a content element,</li> <li>and a body_end element</li> </ul> <p>returning an element that represents the html page structure.</p> <p>Take a look at the <code>default_page</code> as an example: <pre><code>def default_page(header: Element, content: Element, body_end: Element):\n  return HTMLFragment([\n    VEl[\"!DOCTYPE\"](html=None),\n    El.html(content=[\n      El.head(content=[\n        VEl.meta(charset=\"UTF-8\"),\n        VEl.meta(name=\"viewport\", content=\"width=device-width, initial-scale=1.0\"),\n        header\n      ]),\n      El.body(content=[\n        content,\n        body_end\n      ])\n    ])\n  ])\n</code></pre></p>"},{"location":"app/#pagebuilder","title":"<code>PageBuilder</code>","text":"<p>A page builder can be used to modify the contents of a page. An instance of <code>PageBuilder</code> is a <code>page_factory</code>.</p> <p>Using the utility methods, the contents of header, content and body_end can be extended. Let's add a stylesheet to the header: <pre><code>page_builder = PageBuilder()\npage_builder.add_stylesheet(\"/assets/main.css\")\napp = App(element_factory, page_factory=page_builder)\n</code></pre></p> <p>Scripts that should run after the main content is rendered can be appended through <code>add_body_end</code>. <pre><code>page_builder.add_body_end(El.script(content=[UnescapedHTMLElement(\"\"\"\nconsole.log(\"hello world\");\n\"\"\")]))\n</code></pre></p>"},{"location":"asgi/","title":"ASGI","text":"<p>rxxxt ships a set of utilities that make it easier to build and compose ASGI applications alongside <code>App</code>.</p>"},{"location":"asgi/#transport-contexts","title":"Transport contexts","text":"<ul> <li><code>TransportContext</code> exposes the raw ASGI scope, <code>receive</code> and <code>send</code> callables plus helpers for common request metadata.</li> <li><code>HTTPContext</code> builds on <code>TransportContext</code> with helpers such as <code>respond_text</code>, streaming <code>respond_file</code>, and body readers (<code>receive_json</code>, <code>receive_iter</code>, ...).</li> <li><code>WebsocketContext</code> provides <code>setup</code>, <code>receive_message</code>, <code>send_message</code>, and <code>close</code> helpers while tracking the connection state.</li> </ul>"},{"location":"asgi/#handler-decorators","title":"Handler decorators","text":"<ul> <li><code>http_handler</code> wraps a coroutine that receives <code>HTTPContext</code> and filters for HTTP scopes.</li> <li><code>websocket_handler</code> does the same for websocket scopes.</li> <li><code>routed_handler</code> pairs a simple path pattern (using <code>match_path</code>) with a handler and raises <code>ASGINextException</code> so other handlers can try when it does not match.</li> <li><code>http_not_found_handler</code> is a convenience handler that returns a plain 404 response.</li> </ul> <p>These decorators can be used with a <code>Composer</code> instance.</p>"},{"location":"asgi/#example-matching-faviconico","title":"Example: matching <code>/favicon.ico</code>","text":"<pre><code>from rxxxt.asgi import Composer, http_handler, routed_handler, http_not_found_handler\n\ncomposer = Composer()\n\n@composer.add_handler\n@http_handler\n@routed_handler(\"/favicon.ico\")\nasync def favicon(context, params):\n  return await context.respond_file(\"assets/favicon.ico\")\n\ncomposer.add_handler(http_not_found_handler)\n</code></pre> <p>If the request path does not match <code>/favicon.ico</code>, <code>routed_handler</code> raises <code>ASGINextException</code>, allowing the next handler in the <code>Composer</code> chain to run.</p>"},{"location":"asgi/#composer","title":"Composer","text":"<p><code>Composer</code> is a lightweight middleware pipeline that works using the ASGI protocol:</p> <pre><code>from rxxxt.asgi import Composer, http_handler, http_not_found_handler\n\ncomposer = Composer()\n\n@composer.add_handler\n@http_handler\ndef hello(context):\n  return context.respond_text(\"hello\")\n\ncomposer.add_handler(http_not_found_handler)\n</code></pre> <p>Handlers that cannot process a scope should raise <code>ASGINextException</code> (or call <code>context.next()</code> on a <code>TransportContext</code>). <code>Composer</code> will call the next handler in the chain. Add <code>http_not_found_handler</code> as a final fallback to send a simple 404 when no HTTP handler matches.</p>"},{"location":"asgi/#typing-helpers","title":"Typing helpers","text":"<p>The aliases <code>ASGIScope</code>, <code>ASGIFnReceive</code>, <code>ASGIFnSend</code> and <code>ASGIHandler</code> mirror the ASGI call signatures so middleware you write here works with uvicorn, Starlette/FastAPI, or any other ASGI-compatible stack.</p>"},{"location":"component/","title":"<code>Component</code>","text":"<p>Components are stateful html elements that overwrite <code>Component</code>.</p> <p>They can modify and read state, see the state documentation.</p> <p>To render a component the <code>render</code> function must be overwritten.</p> <p>A simple counter component: <pre><code>class Counter(Component):\n  count = local_state(int)\n\n  def on_click(self):\n    self.count += 1\n\n  def render(self) -&gt; Element:\n    return El.div(onclick=self.on_click, content=[f\"Count: {self.count}\"])\n</code></pre></p> <p><code>HandleNavigate</code> can be used as an attribute helper when you only need navigation.</p>"},{"location":"component/#events","title":"Events","text":"<p>Components can receive user input events by a callable as an HTML attribute. For simple interactions you can use plain methods: <pre><code>class Counter(Component):\n  count = local_state(int)\n\n  def on_click(self):\n    self.count += 1\n\n  def render(self) -&gt; Element:\n    return El.button(onclick=self.on_click, content=[f\"Count: {self.count}\"])\n</code></pre></p> <p>Add the <code>event_handler</code> decorator when you need extra capabilities such as <code>InputEventDescriptorOptions</code>, extracting event payloads with <code>Annotated</code> parameters, or the <code>EventHandler.bind</code> helper.</p> <p>Parameters on decorated event handlers can be pre-filled with <code>bind</code>: <pre><code>class AdjustableCounter(Component):\n  count = local_state(int)\n\n  @event_handler()\n  def increase(self, amount: int):\n    self.count += amount\n\n  def render(self) -&gt; Element:\n    return El.div(content=[\n      El.button(onclick=self.increase.bind(amount=5), content=[\"Add 5\"]),\n      El.button(onclick=self.increase.bind(amount=1), content=[\"Add 1\"]),\n    ])\n</code></pre> <code>bind</code> returns a new handler instance using the provided default parameters.</p> <p>The event handlers can then be used as html attributes for the desired events. For example the, <code>onclick</code> event: <pre><code>El.div(onclick=self.on_click, content=[f\"Count: {self.count}\"])\n</code></pre></p> <p>To receive event data from an html event, you can use the <code>Annotated</code> type to specify which fields you would like to map to which function parameter.</p> <p>In the following example the event data <code>target.value</code> is selected from the <code>change</code> event of the rendered input element and passed as the <code>value</code> parameter.</p> <pre><code>from typing import Annotated\nfrom rxxxt import Component, event_handler, VEl, Element\n\nclass InputExample(Component):\n  @event_handler()\n  def on_change(self, value: Annotated[str, \"target.value\"]):\n    print(\"The user entered \", value)\n\n  def render(self) -&gt; Element:\n    return VEl.input(onchange=self.on_change, type=\"text\")\n</code></pre>"},{"location":"component/#custom-output-events","title":"Custom output events","text":"<p><code>Context.emit</code> lets a component notify the browser about arbitrary events. The event name is a string and the payload must be JSON-compatible primitives (<code>int</code>, <code>float</code>, <code>str</code>, <code>bool</code> or <code>None</code>).</p> <p>On the browser side, handlers can be registered through <code>window.rxxxt.on</code>.</p> <pre><code>from rxxxt import App, Component, Element, El, PageBuilder, UnescapedHTMLElement, event_handler\n\nclass Export(Component):\n  @event_handler()\n  def download(self):\n    self.context.emit(\"download\", {\"url\": \"https://example.com/archive.zip\", \"name\": \"archive.zip\"})\n\n  def render(self) -&gt; Element:\n    return El.button(onclick=self.download, content=[\"Download archive\"])\n\npage = PageBuilder()\npage.add_body_end(El.script(content=[\n  UnescapedHTMLElement(\"\"\"\n    rxxxt.on(\"download\", data =&gt; {\n      const link = document.createElement(\"a\");\n      link.download = data.name;\n      link.href = data.url;\n      link.style.display = \"none\";\n      document.body.appendChild(link);\n      link.click();\n      link.remove();\n    });\n  \"\"\")\n]))\n\napp = App(Export, page_factory=page)\n</code></pre> <p>Handlers can be removed with <code>window.rxxxt.off(name, handler)</code>.</p>"},{"location":"component/#background-tasks","title":"Background tasks","text":"<p>Background tasks only run when a session is persistent (using websockets).</p> <p>They can be created in two ways:</p> <ul> <li><code>add_job</code> - creates a task from a coroutine that must be run until finished</li> <li><code>add_worker</code> - creates a task from a coroutine that runs in the background until the component is destroyed. Can be cancelled at any time.</li> </ul>"},{"location":"component/#lifecycle","title":"Lifecycle","text":"<p>A component is alive as long as its parent is not updated.</p> <p>Events:</p> <ul> <li><code>on_init</code> - when the component is initialized</li> <li><code>on_before_destroy</code> - before all background tasks are destroyed</li> <li><code>on_after_destroy</code> - after all background tasks are destroyed</li> </ul>"},{"location":"component/#context","title":"Context","text":"<p>A lot of functionality that is available to components lives inside the component <code>Context</code>.</p>"},{"location":"component/#use-websocket-request-updates","title":"use websocket, request updates","text":"<ul> <li><code>use_websocket</code></li> <li><code>request_update</code></li> </ul>"},{"location":"component/#access-headers-path-query_string-navigate-setget-cookies","title":"access headers, path, query_string, navigate, set/get cookies","text":"<p>properties:</p> <ul> <li><code>cookies</code></li> <li><code>location</code></li> <li><code>path</code></li> <li><code>query_string</code></li> </ul> <p>methods:</p> <ul> <li><code>get_header</code></li> <li><code>set_cookie</code> (<code>mirror_state</code> controls whether the cookie header is updated in state)</li> <li><code>delete_cookie</code> (also honours <code>mirror_state</code>)</li> <li><code>navigate</code></li> <li><code>match_path</code></li> </ul>"},{"location":"component/#manage-subscriptions","title":"manage subscriptions","text":"<ul> <li><code>subscribe</code></li> <li><code>unsubscribe</code></li> <li><code>unsubscribe_all</code></li> </ul>"},{"location":"component/#window-and-query-selector-events","title":"window and query selector events","text":"<p>Use the <code>window_event</code> and <code>query_selector_all_event</code> helpers (available directly from <code>rxxxt</code>) to bind handlers to global window events or existing DOM nodes selected through CSS selectors. These helpers render lightweight virtual elements that automatically register the listener when mounted and remove it when destroyed. Each helper dispatches an <code>emit</code> event whose <code>detail</code> is the original DOM event, so you can use <code>Annotated</code> accessors like <code>detail.key</code> or <code>detail.currentTarget.textContent</code> to pull out data from the browser event.</p> <pre><code>from typing import Annotated\nfrom rxxxt import Component, Element, El, HTMLFragment, event_handler, window_event, query_selector_all_event\n\nclass GlobalEvents(Component):\n  @event_handler()\n  def on_key_press(self, key: Annotated[str, \"detail.key\"]):\n    print(\"key pressed\", key)\n\n  @event_handler()\n  def on_click_p(self, text: Annotated[str, \"detail.currentTarget.textContent\"]):\n    print(\"paragraph clicked\")\n\n  def render(self) -&gt; Element:\n    return HTMLFragment([\n      window_event(\"keydown\", self.on_key_press),\n      query_selector_all_event(\"click\", \"p\", self.on_click_p),\n      El.p(content=[\"Hello World\"]),\n      El.p(content=[\"Hello Universe\"]),\n    ])\n</code></pre>"},{"location":"debugging/","title":"Debugging","text":"<p>Enable verbose error logs by configuring Python's logger before running the server:</p> <pre><code>import logging\n\nlogging.basicConfig(level=logging.DEBUG)\n</code></pre> <p>With the debug log level, rxxxt will print traces when something errors.</p>"},{"location":"elements/","title":"Elements","text":"<ul> <li><code>Element</code> - Abstract base for every renderable element. Implement <code>tonode</code> to describe how the element expands in the tree.</li> <li><code>CustomAttribute</code> - Base class for special attributes that expand into real HTML attributes at render time.</li> <li><code>ElementContent</code> - Sequence of child elements or strings accepted by most element constructors.</li> <li><code>HTMLAttributeValue</code> / <code>HTMLAttributes</code> - Accepted attribute shapes for HTML elements. Non-string primitives are converted.</li> <li><code>lazy_element</code> - Wrap a factory that receives the current <code>Context</code> when the element is rendered.</li> <li><code>TextElement</code> - Escapes text so it can be safely inserted into the DOM tree.</li> <li><code>ScriptContent</code> - Wrap inline script content, escaping closing tags to prevent premature termination.</li> <li><code>ElementFactory</code> - Protocol for callables that create elements.</li> <li> <p><code>El</code> - A way to create html elements quickly.   Write <code>El.&lt;tag name&gt;</code> or <code>El[\"&lt;tag name&gt;\"]</code> to create an element with this tag name.   You may specify attributes by passing them as key values parameters. The inner content is set by specifying the list <code>content</code> with <code>str | Element</code> as children.   Example:   <pre><code># left underscores are stripped from attribute names\nEl.div(_class=\"button\", content=[\"click me\"])\n</code></pre></p> </li> <li> <p><code>VEl</code> - A way to create html void elements (like <code>input</code>, <code>meta</code>, <code>link</code> etc.) quickly.   Write <code>VEl.&lt;tag name&gt;</code> or <code>VEl[\"&lt;tag name&gt;\"]</code> to create an element with this tag name.   You may specify attributes by passing them as key values parameters. Void elements have no inner content.   <pre><code># left underscores are stripped from attribute names\nVEl.input(_type=\"text\")\n</code></pre></p> </li> <li> <p><code>UnescapedHTMLElement</code> - Use this to return raw html strings. Example: <code>UnescapedHTMLElement(\"&lt;h1&gt;Hello World&lt;/h1&gt;\")</code></p> </li> <li> <p><code>HTMLFragment</code> - To create fragments, a container for elements on the same level. Works like react fragments.</p> </li> <li><code>KeyedElement</code> - Sets the rendering key of an element.</li> <li> <p><code>WithRegistered</code> - Registeres values for its child. Intended to be used in combination with <code>self.context.registered(...)</code>.</p> </li> <li> <p><code>HTMLVoidElement</code> - long form of <code>VEl</code>, pass <code>tag: str, attributes: dict[str, str | CustomAttribute | None]</code> to the constructor</p> </li> <li><code>HTMLElement</code> - long form of <code>El</code>, pass <code>tag: str, attributes: dict[str, str | CustomAttribute | None] = {}, content: Iterable[Element | str] = (), key: str | None = None</code> to the constructor</li> <li><code>class_map</code> - Turn a <code>dict[str, bool]</code> into a space separated class string.</li> <li><code>merge_attributes</code> - Merge two attribute dictionaries, normalizing keys and joining <code>class</code> / <code>style</code> values.</li> <li><code>add_attributes</code> - Convenience wrapper to extend an attribute dict with keyword arguments via <code>merge_attributes</code>.</li> </ul>"},{"location":"getting-started/","title":"Getting Started with rxxxt","text":"<p>rxxxt was inspired by React\u2019s component model, but everything renders on the server. Think of each <code>Component</code> as a React component that already runs inside Python: you return a tree of elements, rxxxt streams the resulting HTML to the browser, and DOM events come back as Python method calls.</p>"},{"location":"getting-started/#1-describe-html-with-elements","title":"1. Describe HTML with elements","text":"<p>Just like JSX describes markup in React, the <code>El</code>/<code>VEl</code> helpers describe HTML in Python. Each helper returns an element object that renders into HTML later.</p> <pre><code>&lt;section class=\"card\"&gt;\n  &lt;button disabled&gt;Save&lt;/button&gt;\n  &lt;input type=\"text\"&gt;\n&lt;/section&gt;\n</code></pre> <pre><code>from rxxxt import El, VEl\n\nEl.section(_class=\"card\", content=[\n  El.button(disabled=True, content=[\"Save\"]),\n  VEl.input(type=\"text\"),  # void elements come from VEl.*\n])\n</code></pre> <p>If you know how to read HTML, you already know how to read rxxxt elements.</p>"},{"location":"getting-started/#2-build-your-first-component","title":"2. Build your first component","text":"<p>Components encapsulate logic plus markup, similar to a React component. Override <code>render</code> and return any element tree.</p> <pre><code>from rxxxt import Component, El, Element\n\nclass Hero(Component):\n  def render(self) -&gt; Element:\n    return El.section(_class=\"hero\", content=[\n      El.h1(content=[\"Welcome\"]),\n      El.p(content=[\"All HTML comes from this Python function.\"]),\n    ])\n</code></pre>"},{"location":"getting-started/#3-handle-events-and-state","title":"3. Handle events and state","text":"<p>Use <code>local_state</code> for reactive data and plain methods for event handlers. Unlike React you do not call <code>setState</code>; simply mutate the value and rxxxt re-renders the component. Mount everything with <code>App</code>, the equivalent of <code>createRoot</code>.</p> <pre><code>import uvicorn\nfrom rxxxt import Component, El, Element, App, local_state\n\nclass Counter(Component):\n  count = local_state(int)\n\n  def on_click(self):\n    self.count += 1\n\n  def render(self) -&gt; Element:\n    return El.div(onclick=self.on_click, content=[\n      f\"Count: {self.count}\"\n    ])\n\napp = App(Counter)\nuvicorn.run(app)\n</code></pre> <p>Need debounce/throttle or automatic event payload extraction? Decorate the method with <code>@event_handler</code> and set options such as <code>debounce=300</code> or <code>prevent_default=True</code>.</p>"},{"location":"getting-started/#4-compose-components","title":"4. Compose components","text":"<p>Components can render other components exactly like React: use them beside HTML nodes, nest them, and pass in constructor arguments or state.</p> <pre><code>from rxxxt import Component, El, Element, App\nimport uvicorn\n\nclass Card(Component):\n  def __init__(self, text: str):\n    super().__init__()\n    self._text = text\n\n  def render(self) -&gt; Element:\n    return El.div(_class=\"card\", content=[f\"Happy {self._text}\"])\n\nclass Dashboard(Component):\n  def render(self) -&gt; Element:\n    return El.section(_class=\"wrap\", content=[Card(\"New Year!\")])\n\napp = App(Dashboard)\nuvicorn.run(app)\n</code></pre>"},{"location":"getting-started/#5-route-between-pages","title":"5. Route between pages","text":"<p><code>Router</code> plays the role of React Router. Register callables or components for paths, and read path parameters with <code>router_params</code>.</p> <pre><code>import uvicorn\nfrom rxxxt import App, Component, El, Element, Router, event_handler, local_state, router_params\n\nclass ShowWord(Component):\n  params = router_params()\n  clicks = local_state(int)\n\n  @event_handler()\n  def bump(self):\n    self.clicks += 1\n\n  def render(self) -&gt; Element:\n    return El.div(content=[\n      f\"Word: '{self.params['word']}' \",\n      El.button(onclick=self.bump, content=[f\"clicks: {self.clicks}\"]),\n    ])\n\nrouter = Router()\nrouter.add_route(\"/\", lambda: El.div(content=[\"This text renders on /\"]))\nrouter.add_route(\"/hello/{word}\", ShowWord)\n\napp = App(router)\nuvicorn.run(app)\n</code></pre>"},{"location":"getting-started/#6-load-data-directly-in-python","title":"6. Load data directly in Python","text":"<p>Because rendering all happens server-side, your components can call databases or internal APIs directly. Coroutines work too: declare <code>async def render</code> and <code>await</code> inside it.</p> <pre><code>from rxxxt import Component, El, Element, global_state\n\nclass ShoppingList(Component):\n  user_id = global_state(int)\n\n  async def render(self) -&gt; Element:\n    rows = await sql_select(\"select item, qty from shopping_list where user_id = ?\", self.user_id)\n    return El.ul(content=[\n      El.li(content=[f\"{row['item']} x{row['qty']}\"])\n      for row in rows\n    ])\n</code></pre> <p><code>sql_select</code> is just a placeholder; plug in your own data access code.</p>"},{"location":"getting-started/#next-steps","title":"Next steps","text":"<ul> <li>Learn more about <code>Component</code> lifecycles, events, and decorators.</li> <li>Explore <code>state.md</code> for global, context, and shared state helpers.</li> <li>Use <code>PageBuilder</code> to inject CSS, scripts, or custom markup into the document head/body.</li> <li>Head over to <code>app.md</code> to see how routing, sessions, and background tasks tie together.</li> </ul>"},{"location":"path-matching/","title":"Path Matching","text":"<p><code>match_path</code> compares an incoming path against a pattern and returns a dictionary of extracted parameters when it matches, otherwise <code>None</code>.</p> <pre><code>from rxxxt import match_path\n\nif (params := match_path(\"/projects/{id}\", \"/projects/42\")):\n  print(params[\"id\"])  # -&gt; \"42\"\n</code></pre>"},{"location":"path-matching/#pattern-syntax","title":"Pattern syntax","text":"<ul> <li>Plain text segments must match exactly (case-insensitive by default).</li> <li>Named captures use <code>{name}</code> and are returned in the result dictionary.</li> <li>Appending <code>*</code> to a part (<code>{rest*}</code>) allows matching across multiple path segments.</li> <li>Anonymous captures <code>{}</code> and <code>{*}</code> match without adding a named entry.</li> </ul> <p>Examples:</p> <pre><code>match_path(\"/{name}/{id}\", \"/project/2\")\n# {'name': 'project', 'id': '2'}\n\nmatch_path(\"/{path*}\", \"/project/2\")\n# {'path': 'project/2'}\n</code></pre> <p>Part names must be valid Python identifiers (letters, digits, underscores, and not starting with a digit). Invalid identifiers raise a <code>ValueError</code>, so you get fast feedback when defining routes.</p>"},{"location":"path-matching/#flags-and-customisation","title":"Flags and customisation","text":"<p><code>match_path(pattern, path, re_flags=re.IGNORECASE)</code> accepts any <code>re</code> flag value. Pass <code>re.IGNORECASE | re.VERBOSE</code> (or others) if you need custom matching behaviour.</p>"},{"location":"path-matching/#where-it-is-used","title":"Where it is used","text":"<ul> <li><code>Router</code> relies on <code>match_path</code> to resolve routes and populate <code>router_params</code>.</li> <li><code>routed_handler</code> layers the same pattern matching onto ASGI handlers.</li> </ul>"},{"location":"router/","title":"<code>Router</code>","text":"<p>Routers can be used to match against url paths and extract parameters. A router is an <code>ElementFactory</code> and can be passed directly to the app.</p>"},{"location":"router/#adding-routes","title":"Adding Routes","text":"<p>Routes can be added with <code>add_route</code> supplying the pattern and the element factory for this route. Alternatively routes can be added using decorators.</p> <p><code>add_router</code> merges the routes of another <code>Router</code> instance, which is useful when building feature modules.</p> <pre><code>from rxxxt import Router, El, App\nimport uvicorn\n\nrouter = Router()\n\nchild = Router()\nchild.add_route(\"/child\", lambda: El.div(content=[\"child\"]))\nrouter.add_router(child)\n\ndef hello_factory():\n  return El.div(content=[\"hello\"])\n\nrouter.add_route(\"/hello\", hello_factory)\n\n@router.route(\"/world\")\ndef world_factory():\n  return El.div(content=[\"world\"])\n\napp = App(router)\nuvicorn.run(app)\n</code></pre>"},{"location":"router/#route-patterns","title":"Route Patterns","text":"<p>Routing uses <code>match_path</code>.</p>"},{"location":"router/#accessing-parameters","title":"Accessing Parameters","text":"<p>To access the route parameters the <code>router_params</code> class field can be used inside components.</p> <pre><code>from rxxxt import Router, router_params, Component, event_handler, El, Element, App\nimport uvicorn\n\nclass ShowPath(Component):\n  params = router_params()\n\n  @event_handler()\n  def nav_hello(self): self.context.navigate(\"/hello\")\n\n  @event_handler()\n  def nav_world(self): self.context.navigate(\"/world\")\n\n  def render(self) -&gt; Element:\n    return El.div(content=[\n      El.div(content=[f\"Word: {self.params.get('word', '-')}\"]),\n      El.button(onclick=self.nav_hello, content=[\"nav 'hello'\"]),\n      El.button(onclick=self.nav_world, content=[\"nav 'world'\"]),\n    ])\n\nrouter = Router()\nrouter.add_route(\"/{word}\", ShowPath)\n\napp = App(router)\nuvicorn.run(app)\n</code></pre>"},{"location":"state/","title":"State","text":"<p>State is organized as a key-value store. In order to associate a state with a session accross multiple requests, a token is created. The next request of the same session must include the state token, which will then be used to resolve the associated state.</p> <p>By default the <code>JWTStateResolver</code> is used, which transforms the state into a JWT token, making the server side entirely stateless.</p> <p>This is handled by the <code>StateResolver</code> of the <code>App</code> (default: <code>default_state_resolver</code>).</p>"},{"location":"state/#conventions","title":"Conventions","text":"<p>To handle the livetime of state prefixes are used.</p> <ul> <li>no prefix is global state</li> <li><code>#</code> prefix is temporary state, which will be discarded if no longer used</li> <li><code>!</code> prefix is protocol state, which holds headers and the location (path + query string). This data will always be present for the components, but is only associated with the token, if actually used</li> </ul>"},{"location":"state/#with-components","title":"with Components","text":"<p>There are helpers for defining and using states in Components. These let you define state variables and access them almost like they were native fields. Descriptors such as <code>local_state</code> return the raw value, whereas the <code>_box</code> variants hand you a <code>StateBox</code>. A box exposes a <code>.value</code> attribute so you can both read and assign; writing to <code>.value</code> immediately schedules an update, while mutating the referenced object in-place requires an explicit <code>.update()</code> afterwards to keep dependants in sync.</p> <ol> <li><code>local_state</code> - which is confined to a single component instance <pre><code>from typing import Annotated\nfrom rxxxt import Component, event_handler, VEl, Element, local_state\n\nclass InputExample(Component):\n  text = local_state(str)\n\n  @event_handler(debounce=500)\n  def on_input(self, value: Annotated[str, \"target.value\"]):\n    self.text = value\n\n  def render(self) -&gt; Element:\n    return VEl.input(oninput=self.on_input, type=\"text\", value=self.text)\n</code></pre> Instead of passing a type, you can provide a callable (including lambdas) that returns the initial value. This is useful for non-default defaults: <pre><code>class Counter(Component):\n  count = local_state(lambda: 42, int)  # start at 42 using a lambda factory\n</code></pre></li> <li><code>global_state</code> - which is shared accross the entire application <pre><code>from typing import Annotated\nfrom rxxxt import Component, event_handler, VEl, Element, global_state\n\nclass InputExample(Component):\n  text = global_state(str)\n\n  @event_handler(debounce=500)\n  def on_input(self, value: Annotated[str, \"target.value\"]):\n    self.text = value\n\n  def render(self) -&gt; Element:\n    return VEl.input(oninput=self.on_input, type=\"text\", value=self.text)\n</code></pre></li> <li><code>context_state</code> - which is shared across components down the tree from the first component that uses it <pre><code>from typing import Annotated\nfrom rxxxt import Component, Element, event_handler, VEl, El, context_state\n\nclass Parent(Component):\n  text = context_state(str)\n\n  @event_handler()\n  def on_input(self, value: Annotated[str, \"target.value\"]):\n    self.text = value\n\n  def render(self) -&gt; Element:\n    return El.div(content=[\n      VEl.input(oninput=self.on_input, type=\"text\", value=self.text),\n      Child(),\n    ])\n\nclass Child(Component):\n  text = context_state(str)\n\n  def render(self) -&gt; Element:\n    return El.div(content=[f\"Shared text: {self.text}\"])\n</code></pre></li> <li><code>local_state_box</code> - which is confined to a single component instance, but requires manual updates <pre><code>from rxxxt import Component, Element, El, local_state_box\n\nclass Counter(Component):\n  count = local_state_box(int)\n\n  def increment(self):\n    self.count.value += 1  # assigning to value triggers an update automatically\n\n  def render(self) -&gt; Element:\n    return El.div(content=[\n      El.button(onclick=self.increment, content=[\"Add one\"]),\n      El.span(content=[f\"Count: {self.count.value}\"]),\n    ])\n</code></pre></li> <li><code>global_state_box</code> - which is shared accross the entire application, but requires manual updates <pre><code>from typing import Annotated\nfrom rxxxt import Component, event_handler, VEl, Element, global_state_box\n\nclass InputExample(Component):\n  text = global_state_box(str)\n\n  @event_handler(debounce=500)\n  def on_input(self, value: Annotated[str, \"target.value\"]):\n    self.text.value = value  # simple assignments propagate automatically\n\n  def render(self) -&gt; Element:\n    return VEl.input(oninput=self.on_input, type=\"text\", value=self.text.value)\n</code></pre></li> <li> <p><code>context_state_box</code> - which is shared across components down the tree from the first component that uses it, but requires manual updates <pre><code>from rxxxt import Component, Element, context_state_box, El, event_handler\n\ndef default_settings() -&gt; dict[str, int]:\n  return {\"visits\": 0}\n\nclass SharedData(Component):\n  settings = context_state_box(default_settings)\n\n  @event_handler()\n  def add_visit(self):\n    self.settings.value[\"visits\"] += 1\n    self.settings.update()  # notify that nested data changed in-place\n\n  def render(self) -&gt; Element:\n    return El.div(content=[\n      El.button(onclick=self.add_visit, content=[\"Add visit\"]),\n      El.span(content=[f\"Visits: {self.settings.value['visits']}\"]),\n    ])\n</code></pre></p> </li> <li> <p><code>SharedExternalState</code> - server-only shared state that stays outside the session token. Declare it on the component class with an initial value, call <code>self.context.use_websocket()</code> so updates can be pushed to clients, read the data via <code>.value</code>, and call <code>.update()</code> whenever you mutate that value in place so every subscribing component refreshes. <pre><code>from rxxxt import Component, Element, SharedExternalState, event_handler, El\n\nclass Scoreboard(Component):\n  stats = SharedExternalState({\"blue\": 0, \"red\": 0})\n\n  async def on_init(self):\n    self.context.use_websocket()\n\n  @event_handler()\n  def add_blue(self):\n    self.stats.value[\"blue\"] += 1\n    self.stats.update()  # notify after changing the shared dict in place\n\n  def render(self) -&gt; Element:\n    return El.div(content=[\n      El.div(content=[f\"Blue: {self.stats.value['blue']}\"]),\n      El.div(content=[f\"Red: {self.stats.value['red']}\"]),\n      El.button(onclick=self.add_blue, content=[\"Add point\"]),\n    ])\n</code></pre> See <code>examples/chat.py</code> for a larger example that streams shared messages through this descriptor.</p> </li> </ol>"}]}